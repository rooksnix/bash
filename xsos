os v0.1.9 last mod 2013/04/21
# Latest version at <http://github.com/ryran/xsos>
# Copyright 2012, 2013 Ryan Sawhill <rsaw@redhat.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------

# So much still to do ... Suggestions always welcome though.

# To make it easy to rename the script filename
pzero=xsos

# Get version from line #2
version=$(sed '2q;d' $0)

# Colors and colors and colors oh my (but only for bash v4)
if [[ $BASH_VERSINFO -ge 4 ]]; then
declare -A c
  c[reset]='\033[0;0m'; c[BOLD]='\033[1;1m'
  c[dgrey]='\033[0;30m'; c[DGREY]='\033[1;30m'; c[bg_DGREY]='\033[40m'
  c[red]='\033[0;31m'; c[RED]='\033[1;31m'; c[bg_RED]='\033[41m'
  c[green]='\033[0;32m'; c[GREEN]='\033[1;32m'; c[bg_GREEN]='\033[42m'
  c[orange]='\033[0;33m'; c[ORANGE]='\033[1;33m'; c[bg_ORANGE]='\033[43m'
  c[blue]='\033[0;34m'; c[BLUE]='\033[1;34m'; c[bg_BLUE]='\033[44m'
  c[purple]='\033[0;35m'; c[PURPLE]='\033[1;35m'; c[bg_PURPLE]='\033[45m'
  c[cyan]='\033[0;36m'; c[CYAN]='\033[1;36m'; c[bg_CYAN]='\033[46m'
  c[lgrey]='\033[0;37m'; c[LGREY]='\033[1;37m'; c[bg_LGREY]='\033[47m'
fi

# ==============================================================================
# ENVIRONMENT VARIABLES -- Modify these by setting them in your shell
# environment, e.g. ~/.bash_profile or /etc/profile.d/xsos.sh
#
# COLORS
#
# XSOS_COLORS (bool: y/n)
# Controls whether color is enabled or disabled by default
# Can also be controlled by cmdline arg
      [[ -z $XSOS_COLORS ]] && XSOS_COLORS=y
#
# XSOS_COLOR_RESET -- color to reset terminal to after using other colors
      [[ -z $XSOS_COLOR_RESET ]] && XSOS_COLOR_RESET=${c[reset]}
#
# XSOS_COLOR_H1 -- color for content modules' primary header
      [[ -z $XSOS_COLOR_H1 ]] && XSOS_COLOR_H1=${c[RED]}
#
# XSOS_COLOR_H2 -- color for content modules' secondary header
      [[ -z $XSOS_COLOR_H2 ]] && XSOS_COLOR_H2=${c[PURPLE]}
#
# XSOS_COLOR_H3 -- color for content modules' tertiary header
      [[ -z $XSOS_COLOR_H3 ]] && XSOS_COLOR_H3=${c[BLUE]}
#
# XSOS_COLOR_H4 -- color used only for SYSCTL() module
      [[ -z $XSOS_COLOR_H4 ]] && XSOS_COLOR_H4=${c[reset]}
#
# XSOS_COLOR_IMPORTANT -- color for drawing attention to important data
      [[ -z $XSOS_COLOR_IMPORTANT ]] && XSOS_COLOR_IMPORTANT=${c[BOLD]}
#
# XSOS_COLOR_WARN1 -- color for level-1 warnings
      [[ -z $XSOS_COLOR_WARN1 ]] && XSOS_COLOR_WARN1=${c[orange]}
#
# XSOS_COLOR_WARN2 -- color for level-2 warnings
      [[ -z $XSOS_COLOR_WARN2 ]] && XSOS_COLOR_WARN2=${c[ORANGE]}
#
# XSOS_COLOR_MEMGRAPH_MEMUSED -- color for MemUsed in MEMINFO() graph
      [[ -z $XSOS_COLOR_MEMGRAPH_MEMUSED ]] && XSOS_COLOR_MEMGRAPH_MEMUSED=${c[green]}
#
# XSOS_COLOR_MEMGRAPH_HUGEPAGES -- color for HugePages in MEMINFO() graph
      [[ -z $XSOS_COLOR_MEMGRAPH_HUGEPAGES ]] && XSOS_COLOR_MEMGRAPH_HUGEPAGES=${c[cyan]}
#
# XSOS_COLOR_MEMGRAPH_BUFFERS -- color for Buffers in MEMINFO() graph
      [[ -z $XSOS_COLOR_MEMGRAPH_BUFFERS ]] && XSOS_COLOR_MEMGRAPH_BUFFERS=${c[purple]}
#
# XSOS_COLOR_MEMGRAPH_CACHED -- color for Cached in MEMINFO() graph
      [[ -z $XSOS_COLOR_MEMGRAPH_CACHED ]] && XSOS_COLOR_MEMGRAPH_CACHED=${c[blue]}
#
# XSOS_COLOR_MEMGRAPH_DIRTY -- color for Dirty in MEMINFO() graph
      [[ -z $XSOS_COLOR_MEMGRAPH_DIRTY ]] && XSOS_COLOR_MEMGRAPH_DIRTY=${c[red]}
#
# XSOS_COLOR_IFUP -- color for ethtool InterFace "up"
      [[ -z $XSOS_COLOR_IFUP ]] && XSOS_COLOR_IFUP=${c[green]}
#
# XSOS_COLOR_IFDOWN -- color for ethtool InterFace "down"
      [[ -z $XSOS_COLOR_IFDOWN ]] && XSOS_COLOR_IFDOWN=${c[red]}
#
#
# INDENTATION
# The following variables are not used universally and that might not change
#
# XSOS_INDENT_H1 -- 1st level of indentation
      [[ -z $XSOS_INDENT_H1 ]] && XSOS_INDENT_H1=" "
#
# XSOS_INDENT_H2 -- 2nd level of indentation
      [[ -z $XSOS_INDENT_H2 ]] && XSOS_INDENT_H2=" "
#
# XSOS_INDENT_H3 -- 3rd level of indentation
      [[ -z $XSOS_INDENT_H3 ]] && XSOS_INDENT_H3=" "
#
#
# XSOS_FOLD_WIDTH (w, 0, or positive number)
# Some content modules print line of unpredictable length
# This setting controls the wrapping width for commands that use it
# Changing to w causes width of terminal to be used
# Changing to 0 causes 99999 to be used
    [[ -z $XSOS_FOLD_WIDTH ]] && XSOS_FOLD_WIDTH=94
#
#
# XSOS_UPDATE_CONFIRM (bool: y/n)
# Controls whether built-in update function prompts for confirmation
    [[ -z $XSOS_UPDATE_CONFIRM ]] && XSOS_UPDATE_CONFIRM=y
#
#
# XSOS_HEADING_SEPARATOR (str)
# Acts as a separator between content modules
# Should include at least 1 trailing new-line
    [[ -z $XSOS_HEADING_SEPARATOR ]] && XSOS_HEADING_SEPARATOR="\n"
#
#
# XSOS_ALL_VIEW (str of variables, semicolon-separated)
# Controls what content modules to run when -a/--all switch is used
    [[ -z $XSOS_ALL_VIEW ]] && XSOS_ALL_VIEW='bios=y; os=y; cpu=y; mem=y; disks=y; lspci=y; ethtool=y; ip=y; net=y; sysctl=y; ps=y'
#
#
# XSOS_DEFAULT_VIEW (str of variables, semicolon-separated)
# Controls default content modules, i.e. what to run when none are specififed
    [[ -z $XSOS_DEFAULT_VIEW ]] && XSOS_DEFAULT_VIEW='os=y'
#
#
# XSOS_PS_LEVEL (int: 0-4)
# Controls verbosity level (4 being highest) in PSCHECK() function
    [[ -z $XSOS_PS_LEVEL ]] && XSOS_PS_LEVEL=1
#
#
# XSOS_MEM_UNIT (str: b, k, m, g, t)
# Sets unit used by MEMINFO() function for printing
# Can also be controlled by cmdline opt -u/--unit
    [[ -z $XSOS_MEM_UNIT ]] && XSOS_MEM_UNIT="g"
#
#
# XSOS_NET_UNIT (str: b, k, m, g, t)
# Sets unit used by PROC_NET() function for printing Rx & Tx Bytes
# Can also be controlled by cmdline opt -u/--unit
    [[ -z $XSOS_NET_UNIT ]] && XSOS_NET_UNIT="m"
#
#
# XSOS_PS_UNIT (str: k, m, g)
# Sets unit used by PSCHECK() function for printing VSZ & RSS
# Not affected by cmdline opt -u/--unit option
    [[ -z $XSOS_PS_UNIT ]] && XSOS_PS_UNIT="m"
#
#
# XSOS_OUTPUT_HANDLER (str: application name)
# Sets name of application to handle output
    [[ -z $XSOS_OUTPUT_HANDLER ]] && XSOS_OUTPUT_HANDLER="cat"
#
# XSOS_OS_RHT_CENTRIC (bool: y/n)
# Configures whether OSINFO() focuses on Red Hat support issues
    [[ -z $XSOS_OS_RHT_CENTRIC ]] && XSOS_OS_RHT_CENTRIC="n"
#
# ==============================================================================


VERSINFO() {
  echo "Version info: ${version:2}
See <github.com/ryran/xsos> to report bugs or suggestions"
  exit
}

HELP_USAGE() {
  echo "Usage: $pzero [DISPLAY OPTIONS] [-abocmdleinsp] [SOSREPORT ROOT]
or: $pzero [DISPLAY OPTIONS] {--B|--C|--M|--D|--L|--I|--N|--P FILE}...
or: $pzero [-?|-h|--help]
or: $pzero [-U|--update]

Display system info from localhost or extracted sosreport"
}

HELP_OPTS_CONTENT() {
  echo "
Content options:"
  echo "
-a, --all❚show everything
-b, --bios❚show info from dmidecode
-o, --os❚show hostname, distro, SELinux, kernel info, uptime, etc
-c, --cpu❚show info from /proc/cpuinfo
-m, --mem❚show info from /proc/meminfo
-d, --disks❚show info from /proc/partitions + dm-multipath
-l, --lspci❚show info from lspci
-e, --ethtool❚show info from ethtool
-i, --ip❚show info from ip addr (BASH v4+ required)
-n, --net❚show info from /proc/net/dev
-s, --sysctl❚show important kernel sysctls
-p, --ps❚inspect running processes via ps" | column -ts❚
}

HELP_OPTS_DISPLAY() {
  echo "
Display options:"
  echo "
--rhsupport❚tweak os output to focus on RHEL-centric support issues
-u, --unit=P❚change byte display for /proc/meminfo & /proc/net/dev,
❚where P is \"b\" for byte, or else \"k\", \"m\", \"g\", or \"t\"
-v, --verbose=NUM❚specify ps verbosity level (0-4, default: 1)
-w, --width=NUM❚change fold-width (w autodetects, 0 disables, default: 94)
-x, --nocolor❚disable output colorization
-y, --less❚send output to \`less -SR\`
-z, --more❚send output to \`more\`" | column -ts❚
}

HELP_OPTS_SPECIAL() {
  echo "
Special options (BASH v4+ required):"
  echo "
--B=FILE❚read from FILE containing \`dmidecode\` dump
--C=FILE❚read from FILE containing /proc/cpuinfo dump
--M=FILE❚read from FILE containing /proc/meminfo dump
--D=FILE❚read from FILE containing /proc/partitions dump
--L=FILE❚read from FILE containing \`lspci\` dump
--I=FILE❚read from FILE containing \`ip addr\` dump
--N=FILE❚read from FILE containing /proc/net/dev dump
--P=FILE❚read from FILE containing \`ps aux\` dump" | column -ts❚
}

HELP_SHORT() {
  HELP_USAGE
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  HELP_OPTS_SPECIAL
  echo -e "\nRun with \"--help\" to see full help page\n"
  VERSINFO
}

HELP_EXTENDED() {
  HELP_USAGE
  echo "Run with \"-h\" to see simplified help page"
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  echo "
If no content options are specified, $pzero parses the environment variable
XSOS_DEFAULT_VIEW to figure out what information to display. If this variable
is unset at runtime, it is initialized internally as follows:

XSOS_DEFAULT_VIEW='os=y;'

Tweak it to preference by adding additional semicolon-separated MODULE=y
statements, where MODULE is the same as the long option (e.g. mem, ethtool).

If SOSREPORT ROOT isn't provided, the data will be gathered from the localhost;
however, bios, multipath, and ethtool output will only be displayed if running
as root (UID 0). When executing in this manner as non-root, those modules will
be skipped, and a warning printed to stderr.

Sometimes a full sosreport isn't available; sometimes you simply have a
dmidecode-dump or the contents of /proc/meminfo and you'd like a summary..."
  HELP_OPTS_SPECIAL
  echo "
As is hopefully clear, each of these options requires a filename as an
argument. These options can be used together, but cannot be used in concert
with regular \"Content options\" -- Content opts are ignored if Special options
are detected. Also note: the \"=\" can be replaced with a space if desired.

Re BASH v4+:
BASH associative arrays are used for various things. In short, if running
$pzero on earlier BASH versions (e.g. RHEL5), you get ...
* No output colorization
* No -i/--ip
* No parsing of \"Special options\"

Environment variables:
For details of all configurable env variables, view first page of $pzero
source. There are vars to change default colors as well as other settings.
Each variable name is prefixed with \"XSOS_\" and the important ones follow.
COLORS FOLD_WIDTH ALL_VIEW DEFAULT_VIEW HEADING_SEPARATOR
MEM_UNIT NET_UNIT PS_UNIT PS_LEVEL UPDATE_CONFIRM OUTPUT_HANDLER
"
  VERSINFO
}


UPDATE() {
  echo -e "${c[blue]}Checking $0 against latest version at github.com/ryran/xsos ...${c[DGREY]}\n"
  latest_version_file=$(mktemp --tmpdir xsos_latest.XXXXX) || {
    echo -e "${c[RED]}Unable to create temporary file with mktemp${c[reset]}"
    exit 73
  }
  trap "rm '$latest_version_file'" EXIT

  # Download latest version of xsos with wget or curl
  if command -v wget >/dev/null; then
wget https://raw.github.com/ryran/xsos/master/xsos -O "$latest_version_file" || {
      ret=$?
      echo -e "${c[RED]}Exiting due to wget error${c[reset]}"
      exit $ret
    }
  elif command -v curl >/dev/null; then
curl https://raw.github.com/ryran/xsos/master/xsos -o "$latest_version_file" && echo || {
      ret=$?
      echo -e "${c[RED]}Exiting due to curl error${c[reset]}"
      exit $ret
    }
  else
echo -e "${c[RED]}Need either wget or curl in PATH to download the latest version${c[reset]}"
    exit 72
  fi
  
  # Save version string
  latest_version=$(sed '2q;d' "$latest_version_file")

  # Compare currently running xsos with downloaded file
  if ! diff "$0" "$latest_version_file" >/dev/null; then
echo -e "${c[blue]}The version you are running reports as:\n\t${c[orange]}${version:2}${c[blue]}\nThe version on github appears to be different and reports as:\n\t${c[ORANGE]}${latest_version:2}${c[blue]}"
    if [[ $XSOS_UPDATE_CONFIRM != n ]]; then
echo -e "Type ${c[GREEN]}y${c[blue]} to see the differences between them, or else any other key${c[reset]}"
      read -p "> "
      if [[ $REPLY == y ]]; then
if [[ -n $DISPLAY ]] && command -v meld >/dev/null; then
meld "$0" "$latest_version_file" 2>/dev/null
        elif [[ -n $DISPLAY ]] && command -v gvimdiff >/dev/null; then
gvimdiff "$0" "$latest_version_file" 2>/dev/null
        elif command -v vimdiff; then
vimdiff "$0" "$latest_version_file"
        else
          # set name of tmp diff file
          diff_file=$latest_version_file.patch; trap "rm '$diff_file'" EXIT;
          # create a diff file
          diff -u "$0" "$latest_version_file" > "$diff_file"
          if [[ -n $DISPLAY ]] && command -v gedit >/dev/null; then
gedit "$diff_file" 2>/dev/null
          else
less "$diff_file"
          fi
fi
fi
fi
    [[ -w $0 ]] || {
      echo -e "${c[RED]}You do not have write permission to modify '$0'${c[reset]}"
      exit 77
    }
    if [[ $XSOS_UPDATE_CONFIRM != n ]]; then
echo -e "${c[blue]}Type ${c[GREEN]}u${c[blue]} to replace $0 with the latest version\nOr any other key to cancel${c[reset]}"
      read -p "> "
    else
REPLY=u
    fi
if [[ $REPLY == u ]]; then
echo -e "${c[blue]}Backing up current version and replacing it with downloaded version ...${c[cyan]}"
      cp -v "$0" "$(mktemp --tmpdir xsos-$(awk {print\$3} <<<"$version").XXX)"
      cp -v "$latest_version_file" "$0"
      chmod +x "$0"
      echo -e "${c[reset]}"
    else
echo -e "${c[cyan]}Not performing update${c[reset]}\n"
    fi
else
echo -e "${c[blue]}$0 is the same version as what is on github, i.e.,\n\t${c[BLUE]}${version:2}${c[reset]}\n"
  fi
exit
}


# Help? Version? Update?
case $1 in
  -\?|-h) HELP_SHORT
;;
  --help|help) HELP_EXTENDED
;;
  -V|--vers|--version) echo "Version info: ${version:2}"; exit
;;
  -U|--update) UPDATE
esac

# GNU getopt short and long options:
sopts='u:v:w:xyzabocmdleinsp'
lopts='rhsupport,unit:,verbose:,width:,nocolor,less,more,all,bios,os,cpu,mem,disks,lspci,ethtool,ip,net,sysctl,ps,B:,C:,M:,D:,L:,I:,N:,P:'

# Check for bad switches
getopt -Q --name=$pzero -o $sopts -l $lopts -- "$@" || { HELP_USAGE; exit 64; }

# Setup assoc array for single-file options
unset sfile
[[ $BASH_VERSINFO -ge 4 ]] && declare -A sfile

# Checker for cmdline options
_OPT_CHECK() {
  local option chosen_opt check_type valid_opts n s
  option=$1
  chosen_opt=$(tr '[:upper:]' '[:lower:]' <<<"$2")
  check_type=$3
  valid_opts=$4
  if [[ $option == width ]]; then
egrep -qs '^[0-9]*$|^w$' <<<"$chosen_opt" && return
echo "$pzero: option '$option' expects a positive number or 'w' (auto-detect width) or '0' (disable wrapping)"
  
  elif [[ $check_type == range ]]; then
for n in $(seq $valid_opts); do
      [[ $n == $chosen_opt ]] && return
done
echo "$pzero: option '$option' expects number from range: { ${valid_opts// /-} }"
    
  elif [[ $check_type == naturalnumber ]]; then
grep -qs '^[0-9]*$' <<<"$chosen_opt" && return
echo "$pzero: option '$option' expects any natural number, including zero"
    
  elif [[ $check_type == string ]]; then
for s in $valid_opts; do
      [[ $s == $chosen_opt ]] && return
done
echo "$pzero: option '$option' expects one of: { $valid_opts } "
  fi
exit 64
}


# Parse command-line arguments
PARSE() {
  unset opts all bios os cpu mem disks lspci ethtool ip net sysctl ps
  until [[ $1 = -- ]]; do
case $1 in
      -u|--unit) _OPT_CHECK "unit" "$2" string "b k m g t"
                      XSOS_MEM_UNIT=$2; XSOS_NET_UNIT=$2; shift 2
                    ;;
      -v|--verbose) _OPT_CHECK "verbose" "$2" range "0 4"
                      XSOS_PS_LEVEL=$2; shift 2
                    ;;
      -w|--width) _OPT_CHECK "width" "$2"
                      XSOS_FOLD_WIDTH=$2; shift 2
                    ;;
      -x|--nocolor) shift; XSOS_COLORS=n ;;
      -y|--less) shift; XSOS_OUTPUT_HANDLER='less -SR' ;;
      -z|--more) shift; XSOS_OUTPUT_HANDLER='more' ;;
      --rhsupport) shift; XSOS_OS_RHT_CENTRIC=y ;;
      -a|--all) shift; opts=y; all=y ;;
      -b|--bios) shift; opts=y; bios=y ;;
      -o|--os) shift; opts=y; os=y ;;
      -c|--cpu) shift; opts=y; cpu=y ;;
      -m|--mem) shift; opts=y; mem=y ;;
      -d|--disks) shift; opts=y; disks=y ;;
      -l|--lspci) shift; opts=y; lspci=y ;;
      -e|--ethtool) shift; opts=y; ethtool=y ;;
      -i|--ip) shift; opts=y; ip=y ;;
      -n|--net) shift; opts=y; net=y ;;
      -s|--sysctl) shift; opts=y; sysctl=y ;;
      -p|--ps) shift; opts=y; ps=y ;;
      
      --B) sfile[B]=$2; shift 2 ;;
      --C) sfile[C]=$2; shift 2 ;;
      --M) sfile[M]=$2; shift 2 ;;
      --D) sfile[D]=$2; shift 2 ;;
      --L) sfile[L]=$2; shift 2 ;;
      --I) sfile[I]=$2; shift 2 ;;
      --N) sfile[N]=$2; shift 2 ;;
      --P) sfile[P]=$2; shift 2 ;;
    esac
done
shift #(to get rid of the '--')
  # Set sosroot
  sosroot=$1
}

# Call the parser
PARSE $(getopt -u --name=$pzero -o $sopts -l $lopts -- "$@")

# If any special option was used appropriately with a file, do that instead of other opts
if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
  :
# If BASH is not v4+ and special options were used, fail
elif [[ $BASH_VERSINFO -lt 4 && -n $sfile ]]; then
echo "Special options require use of BASH associative arrays" >&2
  echo "i.e., BASH v4.0 or higher (RHEL6/Fedora11 and above)" >&2
  exit 32
# Use default view if no content options specified
elif [[ -z $opts ]]; then
eval $XSOS_DEFAULT_VIEW
# Else, if "all" option specified, set full view
elif [[ -n $all ]]; then
eval $XSOS_ALL_VIEW
fi

# If color should be enabled, taste the rainbow
if [[ $XSOS_COLORS == y && $BASH_VERSINFO -ge 4 ]]; then
c[0]=$XSOS_COLOR_RESET
  c[H1]=$XSOS_COLOR_H1
  c[H2]=$XSOS_COLOR_H2
  c[H3]=$XSOS_COLOR_H3
  c[H4]=$XSOS_COLOR_H4
  c[Imp]=$XSOS_COLOR_IMPORTANT
  c[Warn1]=$XSOS_COLOR_WARN1
  c[Warn2]=$XSOS_COLOR_WARN2
  c[Up]=$XSOS_COLOR_IFUP
  c[Down]=$XSOS_COLOR_IFDOWN
  c[MemUsed]=$XSOS_COLOR_MEMGRAPH_MEMUSED
  c[HugePages]=$XSOS_COLOR_MEMGRAPH_HUGEPAGES
  c[Buffers]=$XSOS_COLOR_MEMGRAPH_BUFFERS
  c[Cached]=$XSOS_COLOR_MEMGRAPH_CACHED
  c[Dirty]=$XSOS_COLOR_MEMGRAPH_DIRTY
else
unset c
fi

# Properly setup fold setting
if [[ $XSOS_FOLD_WIDTH == w ]]; then
XSOS_FOLD_WIDTH=$(($(tput cols)-3))
elif [[ $XSOS_FOLD_WIDTH == 0 ]]; then
XSOS_FOLD_WIDTH=99999
fi



# ON TO THE CONTENT MODULE FUNCTIONS!
# -----------------------------------
# ===================================


DMIDECODE() {
  # Local vars:
  local dmidecode_input
  
  if [[ -z $1 ]]; then
dmidecode_input=$(dmidecode 2>/dev/null)
  elif [[ -f $1 ]]; then
dmidecode_input=$(<"$1")
  elif [[ -r $1/dmidecode ]]; then
dmidecode_input=$(<"$1/dmidecode")
  elif [[ -r $1/sos_commands/kernel.dmidecode ]]; then
dmidecode_input=$(<"$1/sos_commands/kernel.dmidecode")
  fi
echo -e "${c[H1]}DMIDECODE${c[0]}"
  
  # If bad dmidecode input, return
  if head -n3 <<<"$dmidecode_input" | grep -qs 'No such file or directory'; then
echo -en $XSOS_HEADING_SEPARATOR
    return 1
  fi
  
  # Prints "<BIOS Vendor>, <BIOS Version>, <BIOS Release Date>"
  echo -e "${c[H2]} BIOS:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /BIOS Information/' <<<"$dmidecode_input" |
    awk -F: '
/Vendor:/ { Vendor = $2; gsub(/ */, " ", Vendor) }
/Version:/ { Version = $2; gsub(/ */, " ", Version) }
/Release Date:/ { ReleaseDate = $2; gsub(/ */, " ", ReleaseDate) }
END { printf " %s, version%s,%s\n", Vendor, Version, ReleaseDate }
'
  # Prints <SYSTEM Manufacturer>, <SYSTEM Product Name>, <SYSTEM Version>, <SYSTEM Serial Number>, <SYSTEM UUID>
  echo -e "${c[H2]} System:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /System Information/' <<<"$dmidecode_input" |
    awk -F: -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
/Manufacturer:/ { Mfr = $2; gsub(/ */, " ", Mfr) }
/Product Name:/ { Product = $2; gsub(/ */, " ", Product) }
/Version:/ { Version = $2; gsub(/ */, " ", Version) }
/Serial Number:/{ Serial = $2 }
/UUID:/ { UUID = $2 }
END {
printf " %sMfr:%s %s\n", H3, H0, Mfr
printf " %sProd:%s%s\n", H3, H0, Product
printf " %sVers:%s%s\n", H3, H0, Version
printf " %sSer:%s %s\n", H3, H0, Serial
printf " %sUUID:%s%s\n", H3, H0, UUID
}
'
  # Prints <CPU Manufacturer>, <CPU Family>, <CPU Current Speed>, <CPU Version>
  # Prints "<N> of <N> CPU sockets populated, <N> cores/<N> threads per CPU"
  # Prints "<N> total cores, <N> total threads"
  echo -e "${c[H2]} CPU:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /Processor Information/' <<<"$dmidecode_input" |
    awk -F: -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
/Status:/ { SumSockets ++; if ($2 ~ /Populated/) PopulatedSockets ++ }
/Core Count:/ { SumCores += $2; CoresPerCpu = $2 }
/Thread Count:/ { SumThreads += $2; ThreadsPerCpu = $2 }
/Manufacturer:/ { if ($2 ~ /^ *$/) next; Mfr = $2; gsub(/ */, " ", Mfr) }
/Family:/ { if ($2 ~ /^ *$|Other/) next; Family = $2; gsub(/ */, " ", Family) }
/Current Speed:/{ if ($2 ~ /^ *$|Unknown/) next; CpuFreq = $2; gsub(/ */, " ", CpuFreq) }
/Version:/ { if ($2 ~ /^ *$/) next; Version = $2; gsub(/ */, " ", Version) }
END {
printf " %s%d of %d CPU sockets populated, %d cores/%d threads per CPU\n",
H_IMP, PopulatedSockets, SumSockets, CoresPerCpu, ThreadsPerCpu
printf " %d total cores, %d total threads\n", SumCores, SumThreads, H0
printf " %sMfr:%s %s\n", H3, H0, Mfr
printf " %sFam:%s %s\n", H3, H0, Family
printf " %sFreq:%s%s\n", H3, H0, CpuFreq
printf " %sVers:%s%s\n", H3, H0, Version
}
'
  # Prints "<N> MB (<N> GB) total"
  # Prints "<N> of <N> DIMMs populated (max capacity <N>)"
  echo -e "${c[H2]} Memory:${c[0]}"
  awk 'BEGIN { RS="\nHandle" } /Physical Memory Array|Memory Device/' <<<"$dmidecode_input" |
    awk -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
/Size:/ { NumDimmSlots ++; if ($2 ~ /^[0-9]/) { NumDimms ++; SumRam+=$2 } }
/Maximum Capacity:/ { MaxRam = $3" "$4 }
END {
printf " %d MB (%.0f GB) total\n", SumRam, SumRam/1024
printf " %d of %d DIMMs populated (system max capacity %s)\n",
NumDimms, NumDimmSlots, MaxRam
}
'
  echo -en $XSOS_HEADING_SEPARATOR
}


_CHECK_DISTRO() {
  # Local vars:
  local OS_INDENT files file
  
  OS_INDENT=" "
  # Parse redhat-release if we have it
  if [[ ! -r $1/etc/redhat-release ]]; then
distro_release="${c[Imp]}[redhat-release]${c[0]} ${c[RED]}(missing)${c[0]}"
    
  else
    # If release is RHEL 4,5,6 in standard expected format ...
    if egrep -e 'Red Hat Enterprise Linux (AS|ES|Desktop|WS) release 4 \((Nahant|Nahant Update [1-9])\)' \
             -e 'Red Hat Enterprise Linux (Client|Server) release 5\.?[0-9]* \(Tikanga\)' \
             -e 'Red Hat Enterprise Linux (Client|Workstation|Server) release 6\.?[0-9]* \(Santiago\)' \
             -qs "$1/etc/redhat-release"; then
    
      # ... And if redhat-release file has more than 1 line ...
      [[ $(wc -l <"$1/etc/redhat-release") -gt 1 ]] &&
      
        # ... Then print it in orange
        distro_release=${c[ORANGE]}$(sed "1!s/^/$OS_INDENT/" <"$1/etc/redhat-release") ||
        
          # Otherwise, if only 1 line, all is well -- print it normally
          distro_release=$(sed "1!s/^/$OS_INDENT/" <"$1/etc/redhat-release")
          
    # If release is not RHEL 4,5,6 in standard expected format, freak out
    else
distro_release=$(sed "1!s/^/$OS_INDENT/" "$1/etc/redhat-release" 2>/dev/null)
      
      if grep -qi fedora <<<"$distro_release"; then
distro_release=${c[bg_BLUE]}$distro_release
      
      elif egrep -qi 'alpha|beta' <<<"$distro_release"; then
distro_release=${c[bg_RED]}${c[ORANGE]}$distro_release
        
      else
distro_release=${c[bg_DGREY]}${c[RED]}$distro_release
      fi
fi
    # Prepend the distro information with "[redhat-release] " and do a little color fun
    distro_release="${c[Imp]}[redhat-release]${c[0]} $distro_release${c[0]}"
  fi

  # Check for any /etc/*-release or /etc/*_version files and add their content to the distro_release variable
  files=$(ls "$1"/etc/*{-release,_version} 2>/dev/null | egrep -sv '/etc/(os|redhat|system)-release')
  if [[ -n $files ]]; then
for file in $files; do
if [[ -r $file ]]; then
distro_release="$distro_release\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} $(sed "1!s/^/$OS_INDENT/" <"$file")"
      elif [[ -L $file ]]; then
distro_release="$distro_release\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} ${c[RED]}(error: broken link)${c[0]}"
      else
distro_release="$distro_release\n$OS_INDENT${c[Imp]}[${file##*/}]${c[0]} ${c[RED]}(error: file exists, but cannot read it)${c[0]}"
      fi
done
fi
  
  # I don't like blindly sourcing a file -- that provides a vector to screw with this script...
  # But in modern Linux boxen this file is standard
  # If able to source the new standard /etc/os-release, list it out
  if source "$1/etc/os-release" 2>/dev/null; then
distro_release="$distro_release\n$OS_INDENT${c[Imp]}[os-release]${c[0]} $PRETTY_NAME"
  fi
}


_CHECK_KERNELBUILD() {
  # Get kernel build version somehow or another, making sure not to use build offered by rescue mode kernel
  
  # if localhost: get it from the best place, yay
  if [[ $1 == / ]]; then
kernel_build=$(</proc/version)
  
  # sosreport: sosreports don't normally contain this.. yet
  elif [[ -r "$1/proc/version" ]] && ! grep -qsw rescue "$1/proc/cmdline"; then
kernel_build=$(<"$1/proc/version")
  
  # sosreport: if find it via `dmesg` output file, great
  elif ! grep -qsw rescue "$1/proc/cmdline" && kernel_build=$(grep -s 'Linux version' "$1/sos_commands/general/dmesg"); then
    :
    
  # sosreport: if find it in var/log/dmesg, woo hoo
  elif grep -qs 'Linux version' "$1/var/log/dmesg"; then
kernel_build=$(grep 'Linux version' "$1/var/log/dmesg" | tail -n1)
  
  # sosreport: if find it in var/log/messages, lovely
  elif grep -qs 'kernel: Linux version' "$1/var/log/messages"; then
kernel_build=$(grep 'kernel: Linux version' "$1/var/log/messages" | tail -n1)
  
  # sosreport: final option: search in all old messages files -- this might be a bad idea
  else
    # To explain this last one: The goal is to find the most recent instance of "Linux version"
    # So this reverse-sorts by filename, searches through all files ending with the most recent file
    # This is obviously not very efficient, but it's the only way I've thought of to do it so far
    kernel_build=$(find "$1/var/log" -name 'messages?*' 2>/dev/null | sort -r | xargs zgrep -sh 'kernel: Linux version' 2>/dev/null | tail -n1)
  fi
  
  # Fix format if necessary
  if [[ -n $kernel_build ]]; then
kernel_build=$(sed -e 's,^\[.*\] Linux,Linux,' -e 's,^.*kernel: Linux,Linux,' <<<"$kernel_build")
    kernel_buildhost=$(awk '{print $4}' <<<"$kernel_build")
  fi
}


_CHECK_SELINUX() {
  # Local vars:
  local input_sestatus have_dmesg input_seconfig selinux enforcing selinux_dmesg sestatus_status sestatus_mode sestatus_cfgmode sestatus_policy seconfig_cfgmode seconfig_policy
  
  __cond_print_cfgmode() {
    [[ -n $seconfig_cfgmode ]] &&
      printf " (default $seconfig_cfgmode)" || printf " (default unknown)"
  }
  
  # Grab input from sestatus command if localhost
  if [[ $1 == / ]]; then
input_sestatus=$(sestatus 2>/dev/null)
    
  # Else, from $sosroot/sestatus & dmesg
  else
input_sestatus=$(awk '!/\/.*bin/ && NF!=0' "$1/sestatus" 2>/dev/null)
    egrep -qis '^SELinux: *Disabled at (boot|runtime)' "$1"/var/log/dmesg "$1"/sos_commands/general/dmesg* && selinux_dmesg=disabled
    # Could also check /var/log/messages, but it would be too expensive and complicated
    # to ensure any hits were for the current boot-cycle
  fi
  
  # Read in /etc/selinux/config from sosroot or localhost
  input_seconfig=$(cat "$1"/etc/selinux/config 2>/dev/null)
  
  # Set "selinux" and "enforcing" variables per kernel args
  eval $(egrep -ios 'selinux=.|enforcing=.' "$1"/proc/cmdline | tr '[:upper:]' '[:lower:]')
  
  # Check /etc/selinux/config input
  if [[ -n $input_seconfig ]]; then
eval $(awk -F= '
/^SELINUX=/ { cfgmode = $2 }
/^SELINUXTYPE=/ { policy = $2 }
END {
printf "seconfig_cfgmode=%s; seconfig_policy=%s", cfgmode, policy
}
' <<<"$input_seconfig")
  fi
  
  # Check sestatus input
  if [[ -n $input_sestatus ]]; then
eval $(awk '
/SELinux status/ { status = $NF }
/Current mode/ { mode = $NF }
/Mode from config file/ { cfgmode = $NF }
/Loaded policy|Policy from config/ { policy = $NF }
END {
printf "sestatus_status=%s; sestatus_mode=%s; sestatus_cfgmode=%s; sestatus_policy=%s",
status, mode, cfgmode, policy
}
' <<<"$input_sestatus")
    
    # Since we have sestatus input, primarily rely on that
    if [[ $sestatus_status == disabled ]]; then
      # If sestatus says disabled, need to rely on config file for default mode
      printf "disabled"; __cond_print_cfgmode
    else
      # Otherwise, just use sestatus output
      printf "$sestatus_mode (default $sestatus_cfgmode)"
    fi
  
  # If we don't have sestatus input, things are more complicated...
  else
  
    # If we have selinux/enforcing kernel args, use those for current status
    if [[ -n $selinux || -n $enforcing ]]; then
case $selinux in
        0) printf "disabled" ;;
        1) printf "enforcing" ;;
      esac
case $enforcing in
        0) printf "permissive" ;;
        1) printf "enforcing" ;;
      esac
__cond_print_cfgmode
      
    # If dmesg from sosreport says disabled, print it out
    elif [[ $selinux_dmesg == disabled ]]; then
printf "dmesg says disabled"; __cond_print_cfgmode
      
    # If we only have stuff from /etc/selinux/config
    elif [[ -n $seconfig_cfgmode ]]; then
printf "${c[Warn1]}status unknown${c[0]} (default $seconfig_cfgmode)"
    
    # Otherwise, we have no clue ... :(
    else
printf "${c[Warn1]}status unknown (default unknown)${c[0]}"
    fi
fi
}


_CHECK_GRUB() {
  # Local vars:
  local grubcfg default
  
  # Find the grub config file
  if [[ -f $1/boot/grub/grub.conf ]]; then
    # Set grubcfg for grub1
    grubcfg=$1/boot/grub/grub.conf
  elif [[ -f $1/boot/grub2/grub.cfg ]]; then
    # Set grubcfg for rhel grub2
    grubcfg=$1/boot/grub2/grub.cfg
  elif [[ -f $1/boot/grub/grub.cfg ]]; then
    # Set grubcfg for debian grub2
    grubcfg=$1/boot/grub/grub.cfg
  else
    # Else, we have nothing
    bad_grubcfg="${c[Warn1]}unknown (no grub config file)${c[0]}"
    return 1
  fi
  
  # Check for read permission
  if [[ ! -r $grubcfg ]]; then
    # Set a message for later and stop here
    bad_grubcfg="${c[Warn1]}unknown (no read permission on ${grubcfg##*/})${c[0]}"
    return 1
  fi
case "${grubcfg##*/}" in
    grub.conf)
      # If we have grub.conf, use that
      default=$(awk -F= '/^default=/{print$2}' "$grubcfg" 2>/dev/null)
      [[ -z $default ]] && {
        default=0; default_missing="${c[Warn1]}(Warning: grub.conf lacks \"default=\"; showing title 0)${c[0]}"
      }
      # Get the full kernel line for the default title statement
      grub_cmdline=$(awk /^title/,G "$grubcfg" | egrep -v '^#|^ *#' | sed '1!s/^title.*/\n&/' | awk -vDEFAULT=$((default+1)) -vRS="\n\n" 'NR==DEFAULT' | grep -o '/vmlinuz-.*')
      ;;
    grub.cfg)
      # Otherwise, if we have a grub2 config (grub.cfg), use that
      default=$(awk -F\" '/^set default=/{print$2}' "$grubcfg")
      grub_cmdline=$(awk '/^menuentry.*{/,/^}/' "$grubcfg" | awk -vRS="\n}\n" -vDEFAULT="$((default+1))" 'NR==DEFAULT' | grep -o '/vmlinuz-.*')
  esac
grub_kernel=$(awk {print\$1} <<<"${grub_cmdline#/vmlinuz-}" 2>/dev/null)
  grub_cmdline=$(cut -d' ' -f2- <<<"$grub_cmdline")
}


OSINFO() {
  # Local vars:
  local distro_release kernel_build kernel_buildhost bad_grubcfg default_missing grub_kernel grub_cmdline num_cpu btime hostname kernel serverURL sURLtmp uname systime boottime uptime_input runlevel initdefault timezone
  
  # These functions populate variables for later use
  _CHECK_DISTRO "$1"
  _CHECK_KERNELBUILD "$1"
  _CHECK_GRUB "$1"
  
  # Grab number of cpus from proc/stat
  num_cpu=$(awk '/^cpu[[:graph:]]+/{n++} END{print n}' "$1/proc/stat" 2>/dev/null)
  
  # Grab btime (in seconds since U.Epoch) from proc/stat
  btime=$(awk '/^btime/{print $2}' "$1/proc/stat" 2>/dev/null)
  
  # Grab system hostname & kernel version from /proc first
  hostname=$(cat "$1/proc/sys/kernel/hostname" 2>/dev/null)
  kernel=$(cat "$1/proc/sys/kernel/osrelease" 2>/dev/null)
  
  # Grab RHN serverURL
  if serverURL=$(grep ^serverURL= "$1/etc/sysconfig/rhn/up2date" 2>/dev/null); then
sURLtmp=$(egrep --color=always -si 'oracle' <<<"$serverURL") && serverURL=$sURLtmp
  else
serverURL="${c[red]}(missing)${c[0]}"
  fi
  
  # If running on localhost
  if [[ $1 == / ]]; then
uname=$(uname -a | awk '{printf "mach=%s cpu=%s platform=%s\n", $(NF-3), $(NF-2), $(NF-1)}')
    systime=$(date)
    [[ $(wc -w <<<"$systime") == 6 ]] &&
      systime=$(awk -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '{if ($3 < 10) space=" "; printf "%s %s %s%s %s %s%s%s %s\n", $1,$2,space,$3,$4,H_IMP,$5,H0,$6}' <<<"$systime")
    boottime=$(date --date=@$btime 2>/dev/null)
    [[ $(wc -w <<<"$boottime") == 6 ]] &&
      boottime=$(awk -vH0="${c[0]}" -vH_IMP="${c[Imp]}" -vbtime=$btime '{if ($3 < 10) space=" "; printf "%s %s %s%s %s %s%s%s %s (epoch: %s)\n", $1,$2,space,$3,$4,H_IMP,$5,H0,$6,btime}' <<<"$boottime")
    uptime_input=$(uptime)
    runlevel=$(runlevel)
    initdefault=$(basename $(readlink -q /etc/systemd/system/default.target) 2>/dev/null) &&
      initdefault=${initdefault%.target} ||
        initdefault=$(awk -F: '/^id.*initdefault/ {print $2}' </etc/inittab)
    
  # Otherwise, running on sosreport
  else
    # If sosreport ran in rescue mode, try to get good hostname
    if grep -qsw rescue "$1/proc/cmdline"; then
hostname=$(awk -F= /^HOSTNAME=/{print\$2} "$1/etc/sysconfig/network" 2>/dev/null) ||
        hostname="${c[Warn1]}unknown${c[0]} (sosreport collected from rescue mode)"
    # Otherwise, if no hostname from proc/, try to get from sosroot/hostname or sosroot/uname
    else
      [[ -z $hostname ]] && {
        hostname=$(awk '!/\/.*bin/ && NF!=0' "$1/hostname" 2>/dev/null) ||
          hostname=$(awk '!/\/.*bin/ && NF!=0 {print $2}' "$1/uname" 2>/dev/null) ||
            hostname="${c[Warn1]}unknown${c[0]}"
      }
    fi
    # If sosreport ran in rescue mode, leave it to the kernel-build funness
    if grep -qsw rescue "$1/proc/cmdline"; then
kernel="$kernel ${c[Warn1]}(Rescue mode kernel version)${c[0]}"
    # Otherwise, if no kernel version from proc/, try to get from sosroot/uname
    else
      [[ -z $kernel ]] && {
        kernel=$(awk '!/\/.*bin/ && NF!=0 {print $3}' "$1/uname" 2>/dev/null) ||
          kernel="${c[Warn1]}unknown${c[0]}"
      }
    fi
uname=$(awk '!/\/.*bin/ && NF!=0 {printf "mach=%s cpu=%s platform=%s\n", $(NF-3), $(NF-2), $(NF-1)}' "$1/uname" 2>/dev/null) ||
      uname="${c[Warn1]}unknown${c[0]}"
    # Check kernel for uek
    grep -qsi uek <<<"$kernel" && kernel=$(grep --color=always -i uek <<<"$kernel")
    grep -qsi uek <<<"$grub_kernel" && grub_kernel=$(grep --color=always -i uek <<<"$grub_kernel")
    
    systime=$(awk '!/\/.*bin/ && NF!=0' "$1/date" 2>/dev/null)
    [[ $(wc -w <<<"$systime") == 6 ]] &&
      systime=$(awk -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '{if ($3 < 10) space=" "; printf "%s %s %s%s %s %s%s%s %s\n", $1,$2,space,$3,$4,H_IMP,$5,H0,$6}' <<<"$systime")
    
    timezone=$(awk -F= '/^ZONE=/{print $2}' "$1/etc/sysconfig/clock" 2>/dev/null | tr -d \")
    [[ -n $timezone && -f /usr/share/zoneinfo/$timezone ]] &&
      boottime=$(echo -n $(TZ=$timezone date --date=@$btime 2>/dev/null)) ||
        boottime=$(echo -n $(TZ= date --date=@$btime 2>/dev/null))
    
    [[ $(wc -w <<<"$boottime") == 6 ]] &&
      boottime=$(awk -vH0="${c[0]}" -vH_IMP="${c[Imp]}" -vbtime=$btime '{if ($3 < 10) space=" "; printf "%s %s %s%s %s %s%s%s %s (epoch: %s)\n", $1,$2,space,$3,$4,H_IMP,$5,H0,$6,btime}' <<<"$boottime")
    
    uptime_input=$(awk '!/\/.*bin/ && NF!=0' "$1/uptime")
    [[ -r $1/sos_commands/startup/runlevel ]] && runlevel=$(<"$1/sos_commands/startup/runlevel")
    [[ -r $1/etc/inittab ]] &&
      initdefault=$(awk -F: '/^id.*initdefault/ {print $2}' <"$1/etc/inittab") ||
        initdefault=unknown
  fi
  
  # Start printing stuff
  echo -e "${c[H1]}OS${c[0]}"
  echo -e " ${c[H2]}Hostname:${c[0]} $hostname"
  echo -e " ${c[H2]}Distro:${c[0]} $distro_release"
  echo -e " ${c[H2]}RHN:${c[0]} $serverURL"
  [[ -n $runlevel ]] &&
  echo -e " ${c[H2]}Runlevel:${c[0]} $runlevel (default $initdefault)"
  echo -e " ${c[H2]}SELinux:${c[0]} $(_CHECK_SELINUX "$1")"
  echo -e " ${c[H2]}Arch:${c[0]} $uname"
  echo -e " ${c[H2]}Kernel:${c[0]}"
  echo -e " ${c[H3]}Booted kernel:${c[0]} $kernel"
  echo -e " ${c[H3]}GRUB default:${c[0]} $bad_grubcfg$grub_kernel $default_missing"
  
  # Print and format kernel version
  echo -e " ${c[H3]}Build version:${c[0]}"
  # If kernel build was detected ...
  if [[ -n $kernel_build ]]; then
    # Print a notice if rescue mode
    grep -qsw rescue "$1/proc/cmdline" &&
      echo -e "${c[Warn1]} (Rescue mode detected; build info captured from logs of last boot)${c[0]}"
    # Format it to fit properly
    kernel_build=$(fold -sw$XSOS_FOLD_WIDTH <<<"$kernel_build" | sed 's,^, ,')
    # Change color to warning color (orange) if can't find "build.redhat.com"
    grep -qe '\.z900\.redhat\.com' -e '\.build\.redhat\.com' -e '\.bos\.redhat\.com' -e '\.perf\.redhat\.com' <<<"$kernel_buildhost" ||
      kernel_build="${c[Warn1]}$kernel_build${c[0]}"
    echo -e "$kernel_build"
  else
echo -e "$XSOS_INDENT_H3${c[Warn1]}unknown${c[0]}"
  fi
  
  # Print kernel cmdline from proc/cmdline
  echo -e " ${c[H3]}Booted kernel cmdline:${c[0]}"
  # If rescue mode detected, print a warning
  grep -qsw rescue "$1/proc/cmdline" &&
    echo -e " ${c[Warn1]}(Rescue mode detected)${c[0]}"
  [[ ! -r $1/proc/cmdline ]] &&
    echo -e "$XSOS_INDENT_H3${c[Warn1]}unknown${c[0]}" ||
    fold -sw$XSOS_FOLD_WIDTH "$1/proc/cmdline" 2>/dev/null | sed "s,^,$XSOS_INDENT_H3,"

  echo -e " ${c[H3]}GRUB default kernel cmdline:${c[0]} $default_missing"
  if [[ -n $bad_grubcfg ]]; then
echo -e " $bad_grubcfg"
  else
grep -qs 'unknown.*rescue mode' <<<"$grub_cmdline" &&
      echo -e "$XSOS_INDENT_H3$grub_cmdline" ||
      fold -sw$XSOS_FOLD_WIDTH <<<"$grub_cmdline" 2>/dev/null | sed "s,^,$XSOS_INDENT_H3,"
  fi
    
  # Print kernel tainted-status
  echo -e " ${c[H3]}Taint-check:${c[0]} $(CHECK_TAINTED "$1" H3)"
  # End the kernel section
  echo -e " ${c[DGREY]}- - - - - - - - - - - - - - - - - - -${c[0]}"
  
  ##echo -e " ${c[H2]}Supportability:${c[0]}"
  
  [[ -n $systime ]] &&
  echo -e " ${c[H2]}Sys time:${c[0]} $systime"
  
  # Assuming have uptime input and detected num of cpus, print uptime, loadavg, etc
  [[ -n $uptime_input && -n $num_cpu ]] &&
  awk -vSYSTIME="$systime" -vBTIME="$boottime" -vNUM_CPU="$num_cpu" -vREDBOLD="${c[RED]}" -vRED="${c[red]}" -vORANGE="${c[orange]}" -vGREEN="${c[green]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
!/load average/ { next }
{
Time = $1
Uptime = gensub(/^ *[[:graph:]]+ up +(.+users?),.+/, "\\1", 1)
Load[15] = $(NF)
Load[5] = $(NF-1)
Load[1] = $(NF-2)
for (i in Load) {
sub(/,/, "", Load[i])
LP[i] = Load[i] * 100 / NUM_CPU
}
for (i in LP) {
if (LP[i] < 70) Color[i] = GREEN
if (LP[i] > 69) Color[i] = ORANGE
if (LP[i] > 89) Color[i] = RED
if (LP[i] > 99) Color[i] = REDBOLD
}
if (SYSTIME == "")
printf " %sSys time:%s %s\n", H2, H0, Time
printf " %sBoot time:%s %s\n", H2, H0, BTIME
printf " %sUptime:%s %s\n", H2, H0, Uptime
printf " %sLoadAvg:%s %s[%d CPU]%s %s (%s%.0f%%%s), %s (%s%.0f%%%s), %s (%s%.0f%%%s)\n",
H2, H0, H_IMP, NUM_CPU, H0, Load[1], Color[1], LP[1], H0, Load[5], Color[5], LP[5], H0, Load[15], Color[15], LP[15], H0
}' <<<"$uptime_input"
    
  # Print info from proc/stat
  [[ -n $btime ]] &&
  awk -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" -vH_IMP="${c[Imp]}" '
/^cpu / {
TotalTime = $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9 + $10 + $11
user = $2 * 100 / TotalTime
nice = $3 * 100 / TotalTime
sys = $4 * 100 / TotalTime
idle = $5 * 100 / TotalTime
iowait = $6 * 100 / TotalTime
irq = $7 * 100 / TotalTime
softirq = $8 * 100 / TotalTime
steal = $9 * 100 / TotalTime
#guest = $10
#guest_nice = $11
}
/^cpu[[:graph:]]+/ { num_cpu++ }
/procs_running/ { procs_running = $2 }
/procs_blocked/ { procs_blocked = $2 }
/processes/ { processes = $2 }
END {
printf " %s/proc/stat:%s\n",
H2, H0
printf " %sprocs_running:%s %d %sprocs_blocked:%s %d", H3, H0, procs_running, H3, H0, procs_blocked
printf " %sprocesses [Since boot]:%s %d\n", H3, H0, processes
printf " %scpu [Utilization since boot]:%s\n us %.0f%%, ni %.0f%%, sys %.0f%%, idle %.0f%%, iowait %.0f%%, irq %.0f%%, sftirq %.0f%%, steal %.0f%%\n",
H3, H0, user, nice, sys, idle, iowait, irq, softirq, steal
}
' <"$1/proc/stat"
  
  echo -en $XSOS_HEADING_SEPARATOR
}


CPUINFO() {
  # Local vars:
  local cpuinfo_input model_cpu vendor family num_cpu num_cpu_phys num_threads_per_cpu cpu_cores core_id num_cores_per_cpu cores1 cores2 coresNthreads cpu_flags
  
  [[ -f $1 ]] && cpuinfo_input=$1 || cpuinfo_input=$1/proc/cpuinfo
  
  # Get model of cpu
  model_cpu=$(awk -F: '/^model name/{print $2; exit}' <"$cpuinfo_input")
  
  # If no model detected (e.g. on Itanium), try to use vendor+family
  [[ -z $model_cpu ]] && {
    vendor=$(awk -F: '/^vendor /{print $2; exit}' <"$cpuinfo_input")
    family=$(awk -F: '/^family /{print $2; exit}' <"$cpuinfo_input")
    model_cpu="$vendor$family"
  }
  
  # Clean up cpu model string
  model_cpu=$(sed -e 's,(R),,g' -e 's,(TM),,g' -e 's, *, ,g' -e 's,^ ,,' <<<"$model_cpu")
  
  # Get number of logical processors
  num_cpu=$(awk '/^processor/{n++} END{print n}' <"$cpuinfo_input")
  
  # Get number of physical processors
  num_cpu_phys=$(grep '^physical id' <"$cpuinfo_input" | sort -u | wc -l)
  
  # If "physical id" not found, we cannot make any assumptions (Virtualization--)
  # But still, multiplying by 0 in some crazy corner case is bad, so set it to 1
  # If num of physical *was* detected, add it to the beginning of the model string
  [[ $num_cpu_phys == 0 ]] && num_cpu_phys=1 || model_cpu="$num_cpu_phys $model_cpu"
  
  # If number of logical != number of physical, try to get info on cores & threads
  if [[ $num_cpu != $num_cpu_phys ]]; then
    
    # Detect number of threads (logical) per cpu
    num_threads_per_cpu=$(awk '/^siblings/{print $3; exit}' <"$cpuinfo_input")
    
    # Two possibile ways to detect number of cores
    cpu_cores=$(awk '/^cpu cores/{print $4; exit}' <"$cpuinfo_input")
    core_id=$(grep '^core id' <"$cpuinfo_input" | sort -u | wc -l)
    
    # The first is the most accurate, if it works
    if [[ -n $cpu_cores ]]; then
num_cores_per_cpu=$cpu_cores
    
    # If "cpu cores" doesn't work, "core id" method might (e.g. Itanium)
    elif [[ $core_id -gt 0 ]]; then
num_cores_per_cpu=$core_id
    fi
    
    # If found info on cores, setup core variables for printing
    if [[ -n $num_cores_per_cpu ]]; then
cores1="($((num_cpu_phys*num_cores_per_cpu)) CPU cores)"
      cores2=" / $num_cores_per_cpu cores"
    # If didn't find info on cores, assume single-core cpu(s)
    else
cores2=" / 1 core"
    fi
    
    # If found siblings (threads), setup the variable for the final line
    [[ -n $num_threads_per_cpu ]] &&
      coresNthreads="\n └─$num_threads_per_cpu threads${cores2} each"
  fi
  
  # Check important cpu flags
  # pae=physical address extensions * lm=64-bit * vmx=Intel hw-virt * svm=AMD hw-virt
  # ht=hyper-threading * aes=AES-NI * constant_tsc=Constant Time Stamp Counter
  cpu_flags=$(egrep -o "pae|lm|vmx|svm|ht|aes|constant_tsc" <"$cpuinfo_input" | sort -u | sed ':a;N;$!ba;s/\n/,/g')
  [[ -n $cpu_flags ]] && cpu_flags="(flags: $cpu_flags)"
  
  # Print it all out
  echo -e "${c[H1]}CPU${c[0]}"
  echo -e " ${c[Imp]}${num_cpu} logical processors${c[0]} ${cores1}"
  echo -e " ${model_cpu} ${cpu_flags} ${coresNthreads}"
  echo -en $XSOS_HEADING_SEPARATOR
}


MEMINFO() {
  # Local vars:
  local meminfo_input
  
  [[ -f $1 ]] && meminfo_input=$1 || meminfo_input=$1/proc/meminfo
  
  echo -e "${c[H1]}MEMORY${c[0]}"
  if grep -qsw rescue "$1/proc/cmdline"; then
echo -e "${c[Warn2]} WARNING: RESCUE MODE DETECTED${c[0]}"
    echo -e "${c[Warn1]} meminfo reflects rescue env; inspect sysctl.conf manually for HugePages${c[0]}"
  fi
awk -vu=$(tr '[:lower:]' '[:upper:]' <<<$XSOS_MEM_UNIT) -vcolor_MemUsed="${c[MemUsed]}" -vcolor_HugePages="${c[HugePages]}" -vcolor_Buffers="${c[Buffers]}" -vcolor_Cached="${c[Cached]}" -vcolor_Dirty="${c[Dirty]}" -vcolor_warn="${c[Warn1]}" -vH_IMP="${c[Imp]}" -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" '
# These will come in handy
function round(num, places) {
places = 10 ^ places
return int(num * places + .5) / places
}
function memgraph_special(PercentA, PercentB, Color, PrettyName) {
PercentTotal = PercentA + PercentB
printf " %s%s ", Color, PrettyName
for (i=0; i < round(PercentA/2, 0); i++) printf "◆"
for (i=0; i < round(PercentB/2, 0); i++) printf "◇"
printf H0
for (i=0; i < 50-round(PercentTotal/2, 0); i++) printf "◇"
if (round(PercentTotal,1) > 99.9) j=" "
else if (round(PercentTotal,1) > 9) j=" "
else j=" "
printf "%s%s%.1f%%%s\n", j, Color, PercentTotal, H0
}
function memgraph(Percent, Color, PrettyName) {
printf " %s%s ", Color, PrettyName
for (i=0; i < round(Percent/2, 0); i++) printf "◆"
printf H0
for (i=0; i < 50-round(Percent/2, 0); i++) printf "◇"
if (round(Percent,1) > 99.9) j=" "
else if (round(Percent,1) > 9) j=" "
else j=" "
printf "%s%s%.1f%%%s\n", j, Color, Percent, H0
}
# Grab variables from meminfo
/^MemTotal:/ { MemTotal = $2 }
/^MemFree:/ { MemFree = $2 }
/^Buffers:/ { Buffers = $2 }
/^Cached:/ { Cached += $2 }
/^SwapCached:/ { Cached += $2 }
/^LowTotal:/ { LowTotal = $2 }
/^LowFree:/ { LowFree = $2 }
/^SwapTotal:/ { SwapTotal = $2 }
/^SwapFree:/ { SwapFree = $2 }
/^Dirty:/ { Dirty = $2 }
/^Shmem:/ { Shmem = $2 }
/^Slab:/ { Slab = $2 }
/^PageTables:/ { PageTables = $2 }
/^Hugepagesize:/ { Hugepagesize = $2 }
/^HugePages_Total:/ { HugepagesTotal = $2 }
/^HugePages_Free:/ { HugepagesFree = $2 }
END {
# Compute additional variables
MemUsed = MemTotal - MemFree
Mem_Percent = MemUsed * 100 / MemTotal
Buffers_Percent = Buffers * 100 / MemTotal
Cached_Percent = Cached * 100 / MemTotal
MemUsedNoBC = MemUsed - Buffers - Cached
MemNoBC_Percent = MemUsedNoBC * 100 / MemTotal
Dirty_Percent = Dirty * 100 / MemTotal
Shmem_Percent = Shmem * 100 / MemTotal
Slab_Percent = Slab * 100 / MemTotal
PT_Percent = PageTables * 100 / MemTotal
HP = Hugepagesize * HugepagesTotal
HP_PercentRam = HP * 100 / MemTotal
# If have hugepages, calculate in-use
if (HugepagesTotal > 0) {
HP_Used = (HugepagesTotal - HugepagesFree) * Hugepagesize
HP_Used_Percent = (HugepagesTotal - HugepagesFree) * 100 / HugepagesTotal
}
# Else, need to avoid divide-by-zero errors
else {
HP_Used = 0
HP_Used_Percent = 0
}
# If meminfo has LowTotal (modern x86_64 boxes do not)...
if (LowTotal ~ /[0-9]+/) {
SHOW_Lowmem=1
LowUsed = LowTotal - LowFree
LowUsed_Percent = LowUsed * 100 / LowTotal
}
# Else, avoid divide-by-zero and hide it
else {
SHOW_Lowmem=0
LowTotal = 0
LowUsed = 0
LowUsed_Percent = 0
}
# If have swap-space...
if (SwapTotal > 0) {
SwapUsed = SwapTotal - SwapFree
Swap_Percent = SwapUsed * 100 / SwapTotal
}
# Else, avoid divide-by-zero errors
else {
SwapUsed = 0
Swap_Percent = 0
}
# If meminfo has Shmem, we show it; otherwise not
if (Shmem ~ /[0-9]+/)
SHOW_Shmem=1
else
SHOW_Shmem=0
# If unit is set to B, convert native KiB to bytes
if (u == "B") {
MemUsed *= 1024
MemTotal *= 1024
MemUsedNoBC *= 1024
Dirty *= 1024
Shmem *= 1024
Slab *= 1024
PageTables *= 1024
HP *= 1024
if (HugepagesTotal > 0) HP_Used *= 1024
if (LowTotal > 0) { LowUsed *= 1024; LowTotal *= 1024 }
if (SwapTotal > 0) { SwapUsed *= 1024; SwapTotal *= 1024 }
}
# Figure out what number to divide by to end up with MiB, GiB, or TiB
if (u == "M") divisor = 1024
else if (u == "G") divisor = 1024 ** 2
else if (u == "T") divisor = 1024 ** 3
# If unit is set to M or G or T, do the division to convert from native KiB
if (u == "M" || u == "G" || u == "T") {
MemUsed /= divisor
MemTotal /= divisor
MemUsedNoBC /= divisor
Dirty /= divisor
Shmem /= divisor
Slab /= divisor
PageTables /= divisor
HP /= divisor
if (HugepagesTotal > 0) HP_Used /= divisor
if (LowTotal > 0) { LowUsed /= divisor; LowTotal /= divisor }
if (SwapTotal > 0) { SwapUsed /= divisor; SwapTotal /= divisor }
}
# The unit string used just for printing
if (u == "B")
Unit = " "u
else
Unit = " "u"iB"
# ASCII-ART fun
printf " %sStats graphed as percent of MemTotal:%s\n", H2, H0
# The following line is disabled because it would kinda suck for people that run with NOCOLOR
# Or people that run with color and then copy the output to text -- uncomment it to see what I mean
#memgraph_special(MemNoBC_Percent, Buffers_Percent+Cached_Percent, color_MemUsed, "MemUsed ")
memgraph(Mem_Percent, color_MemUsed, "MemUsed ")
memgraph(Buffers_Percent, color_Buffers, "Buffers ")
memgraph(Cached_Percent, color_Cached, "Cached ")
memgraph(HP_PercentRam, color_HugePages, "HugePages ")
memgraph(Dirty_Percent, color_Dirty, "Dirty ")

# If unit is T, print percentages with no decimal & byteunits with 2-3 decimal-points of precision
if (u == "T") {
Prec_Percent = 0
Prec_BytesLo = 2
Prec_BytesHi = 3
}
# If unit is G, print percentages with no decimal & byteunits with 1-2 decimal-points of precision
else if (u == "G") {
Prec_Percent = 0
Prec_BytesLo = 1
Prec_BytesHi = 2
}
# If unit is B or K or M, print percentages with 1 decimal-point of precision & byteunits with no decimal
else {
Prec_Percent = 1
Prec_BytesLo = 0
Prec_BytesHi = 0
}
# Now time to round off the numbers
Mem_Percent = round(Mem_Percent, Prec_Percent)
MemNoBC_Percent = round(MemNoBC_Percent, Prec_Percent)
Dirty_Percent = round(Dirty_Percent, Prec_Percent)
HP_PercentRam = round(HP_PercentRam, Prec_Percent)
HP_Used_Percent = round(HP_Used_Percent, Prec_Percent)
LowUsed_Percent = round(LowUsed_Percent, Prec_Percent)
Slab_Percent = round(Slab_Percent, Prec_Percent)
PT_Percent = round(PT_Percent, Prec_Percent)
Shmem_Percent = round(Shmem_Percent, Prec_Percent)
Swap_Percent = round(Swap_Percent, Prec_Percent)
MemTotal = round(MemTotal, Prec_BytesLo)
MemUsed = round(MemUsed, Prec_BytesLo)
MemUsedNoBC = round(MemUsedNoBC, Prec_BytesLo)
Dirty = round(Dirty, Prec_BytesHi)
HP = round(HP, Prec_BytesLo)
HP_Used = round(HP_Used, Prec_BytesLo)
LowUsed = round(LowUsed, Prec_BytesLo)
LowTotal = round(LowTotal, Prec_BytesLo)
Slab = round(Slab, Prec_BytesHi)
PageTables = round(PageTables, Prec_BytesHi)
Shmem = round(Shmem, Prec_BytesHi)
SwapUsed = round(SwapUsed, Prec_BytesLo)
SwapTotal = round(SwapTotal, Prec_BytesLo)
printf " %sRAM:%s\n", H2, H0
printf " %s%s%s total ram%s\n", H_IMP, MemTotal, Unit, H0
printf " %s%s (%s%%) used\n", MemUsed, Unit, Mem_Percent
printf " %s%s%s (%s%%) used excluding Buffers/Cached%s\n", H_IMP, MemUsedNoBC, Unit, MemNoBC_Percent, H0
if (Dirty_Percent > 10)
printf " %s%s%s (%s%%) dirty%s\n", color_warn, Dirty, Unit, Dirty_Percent, H0
else
printf " %s%s (%s%%) dirty\n", Dirty, Unit, Dirty_Percent
printf " %sHugePages:%s\n", H2, H0
if (HugepagesTotal == 0)
printf " No ram pre-allocated to HugePages\n"
else {
printf " %s%s%s pre-allocated to HugePages (%s%% of total ram)%s\n", H_IMP, HP, Unit, HP_PercentRam, H0
printf " %s%s of HugePages (%s%%) in-use by applications\n", HP_Used, Unit, HP_Used_Percent
}
printf " %sLowMem/Slab/PageTables/Shmem:%s\n", H2, H0
if (SHOW_Lowmem == 1)
printf " %s%s (%s%%) of %s%s LowMem in-use\n", LowUsed, Unit, LowUsed_Percent, LowTotal, Unit
printf " %s%s (%s%%) of total ram used for Slab\n", Slab, Unit, Slab_Percent
printf " %s%s (%s%%) of total ram used for PageTables\n", PageTables, Unit, PT_Percent
if (SHOW_Shmem == 1)
printf " %s%s (%s%%) of total ram used for Shmem\n", Shmem, Unit, Shmem_Percent
printf " %sSwap:%s\n", H2, H0
if (SwapTotal == 0)
printf " %sNo system swap space configured%s\n", color_warn, H0
else
printf " %s%s (%s%%) used of %s%s total\n", SwapUsed, Unit, Swap_Percent, SwapTotal, Unit
}
' <"$meminfo_input"
  echo -en $XSOS_HEADING_SEPARATOR
}


STORAGE() {
  # Local vars:
  local mpath_input scsi_blacklist bl partitions_input
  
  echo -e "${c[H1]}STORAGE${c[0]}"
  
  # Get mpath input if necessary
  if [[ $2 == --mpath ]]; then
if [[ $1 == / && $UID -eq 0 ]]; then
      # Get multipath input from command, because $1 is system
      mpath_input=$(multipath -v4 -ll 2>/dev/null)
    elif [[ -r $1/sos_commands/devicemapper/multipath_-v4_-ll ]]; then
      # Get multipath input from sosreport file, if present
      mpath_input=$(<"$1/sos_commands/devicemapper/multipath_-v4_-ll")
    fi
fi
  
  # If have good mpath data ..
  if [[ -n $mpath_input ]] && ! egrep -q 'no.paths|multipath.conf.*not.exist' <<<"$mpath_input"; then
echo -e "${c[H2]} Multipath:${c[0]}"
    
    # Print out names & sizes of each multipath map
    egrep -B1 '^\[?size=' <<<"$mpath_input" |
      awk -vRS="--" '
{
printf " %s;%s\n",
$1, gensub(/.*size=([0-9]+\.?[0-9]*) ?([MGT]).*/, "\\1 \\2iB", 1)
}
' | sort | column -ts\;
    
    # Also, create a blacklist containing all paths to LUNS used for multipath
    # This will be used to hide certain devices in the plain "whole disk" output
    scsi_blacklist=$(awk '
# The beginning of this regex is quite odd .. we are matching lines starting with:
# \_ OR |- OR `-
/(\\_|\|-|`-) [0-9]+:[0-9]+:[0-9]+:[0-9]+ +[[:graph:]]+ +[0-9]+:/ {
printf gensub(/.*:[0-9]+ +([[:graph:]]+) +[0-9].*/, "\\1|", 1)
}
' <<<"$mpath_input")
  fi
  
  # If we have linux swraid info, let's use it to expand our blacklist
  if [[ -r $1/proc/mdstat ]]; then
    # Append software raid component disks to the blacklist
    scsi_blacklist=$scsi_blacklist$(grep -s ^md "$1/proc/mdstat" | cut -d\ -f5- | egrep -o '[[:alpha:]]+' | sort -u | awk '{printf "%s|", $1}')
  fi
  
  # Yay, let's go.
  [[ -n $scsi_blacklist ]] && bl=y || { bl=n; scsi_blacklist=NULL; }
  [[ -f $1 ]] && partitions_input=$1 || partitions_input=$1/proc/partitions
  echo -e " ${c[H2]}Whole Disks from /proc/partitions:${c[0]}"
  egrep -v "${scsi_blacklist%?}" "$partitions_input" |
    awk -vblacklisted=$bl -vblacklist_devcount=$(wc -w <<<"${scsi_blacklist//|/ }") -vcolor_grey="${c[DGREY]}" -vH_IMP="${c[Imp]}" -vH3="${c[H3]}" -vH2="${c[H2]}" -vH0="${c[0]}" '
# For starters, we search /proc/partitions for certain types of devices
# (These partition types are from devices.txt in the linux kernel documentation)
$4 ~ /^hd.$|^sd[[:alpha:]]+$|^md.$|^r+om.$|^r?flash.$|^rd\/c.{1,2}d.{1,2}$|^ida\/c.d.$|^i2o\/hd[[:alpha:]]+$|^amiraid\/ar.{1,2}$|cbd\/.$|^cciss\/c.d.{1,2}$|^iseries\/vd[[:alpha:]]+$|^ataraid\/d.{1,2}$|^emd\/.{1,2}$|^carmel\/.{1,2}$|^mmcblk.$|^ub.$|^xvd[[:alpha:]]+$|^vd[[:alpha:]]+$|^dasd[[:alpha:]]+$/ {
# For each thing found, increment the total number of disks
numdisks ++
# Name a key in the array after the disk and then store its size in GiB there
disk[$4] = $3/1024/1024
# Also, add to the total sum of disk-storage
sum_gb += disk[$4]
}
END {
# All done with the data-gathering; so print out a summary
printf " %s%d disks, totaling %.0f GiB (%.2f TiB)%s\n", H_IMP, numdisks, sum_gb, sum_gb/1024, H0
# Print a notice if devices were hidden due to blacklist
if (blacklisted == "y")
printf " %s(%d multipath/mdraid components hidden)%s\n", H_IMP, blacklist_devcount, H0
# Some pretty header-fun
printf " %s- - - - - - - - - - - - - - - - - - - - -%s\n", color_grey, H0
printf " %sDisk \tSize in GiB\n", H3
printf " ----\t-----------%s\n", H0
# Finally, print all the disks & their sizes
n = asorti(disk, disk_sorted)
for (i = 1; i <= n; i++)
printf " %s \t%.0f\n", disk_sorted[i], disk[disk_sorted[i]]
}
'
  echo -en $XSOS_HEADING_SEPARATOR
}


LSPCI() {
  # Local vars:
  local lspci_input
  
  if [[ -z $1 ]]; then
lspci_input=$(lspci)
  elif [[ -f $1 ]]; then
lspci_input=$(<"$1")
  else
lspci_input=$(<"$1/lspci")
  fi

echo -e "${c[H1]}LSPCI${c[0]}"

  awk -vH_IMP="${c[Imp]}" -vH2="${c[H2]}" -vH0="${c[0]}" '
!/Ethernet controller:|Network controller:|Fibre Channel:|Mass storage controller:|InfiniBand:/ {
next
}
{
split($1, slot, ":")
$1 = ""
sub(" ", "")
split($0, type, ":")
dev[type[2]] ++
if (!(slot[1] SUBSEP type[2] in slots)) {
slots[slot[1], type[2]]
slotcount[type[2]] ++
}
}
END {
printf "%s Net/Storage:%s\n", H2, H0
for (devtype in dev) {
slotc = slotcount[devtype]
typec = dev[devtype]
ports = ""
if (typec > 1) {
numports = typec/slotc
if (numports == 1) numports = "single"
else if (numports == 2) numports = "dual"
else if (numports == 3) numports = "triple"
else if (numports == 4) numports = "quad"
ports = " "slotc " " numports "-port"
}
printf " %s%s (%s)%s%s\n", H_IMP, ports, typec, H0, devtype
}
}
' <<<"$lspci_input"
  
  echo -e "${c[H2]} VGA:${c[0]}"
  awk -F: '$2 ~ /^.... VGA/ { print " "$3}' <<<"$lspci_input"
  echo -en $XSOS_HEADING_SEPARATOR
}


IPADDR() {
# I spent a long time wondering how I would end up implementing ip-addr functionality
# I couldn't think of a lovely elegant gawk-way and in the end I wrote this in 2 hours
# This is probably one of the most expensive of the functions

  # Require BASH v4
  if [[ -z $BASH_VERSINFO || $BASH_VERSINFO -lt 4 ]]; then
echo "The -i/--ip option requires use of BASH associative arrays" >&2
    echo "i.e., BASH v4.0 or higher (RHEL6/Fedora11 and above)" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
    return
fi
  
  # Local vars:
  local ip_a_input ipdevs i n ipv4addr alias
  
  # Declare our 6 associative arrays:
  local -A iface_input slaveof ipv4 ipv4_alias state mac
  
  # If localhost, use ip addr
  if [[ -z $1 ]]; then
ip_a_input=$(ip a)
  # If passed a file (i.e. xsos --I <file>), use that
  elif [[ -f $1 ]]; then
ip_a_input=$(<"$1")
  # Otherwise, use file from $sosroot
  else
ip_a_input=$(<"$1/sos_commands/networking/ip_address")
  fi
  
  # Prepare input for awk by separating each interface block
  ip_a_input=$(sed -e 's,^[0-9]*: ,\n&,' -e '1s,^,\n,' <<<"$ip_a_input")
  
  # Grab a list of the interface names
  ipdevs=$(awk -F: 'BEGIN {RS="\n\n"} {print $2}' <<<"$ip_a_input" | egrep -v 'sit0')
  
  # Begin ...
  echo -e "${c[H1]}IP${c[0]}"
  
  # The bracket here is like using parens to make a subshell -- allows to capture all stdout
  {
    # Header info ("❚" is used later by `column` to columnize the output)
    echo " Interface❚Slave Of❚IPv4 Address❚State❚MAC Address"
    echo " =========❚========❚==================❚=====❚================="
    
    # For each interface ($i) found in ip addr output
    for i in $ipdevs; do
      
      # Pull out input for specific interface and save to interface key in array
      iface_input[$i]=$(awk "BEGIN {RS=\"\n\n\"} /^[0-9]+: $i:/" <<<"$ip_a_input")
      
      # Figure out if $i is a slave of some bond device
      slaveof[$i]=$(grep -q SLAVE <<<"${iface_input[$i]}" && egrep -o 'master [[:graph:]]+' <<<"${iface_input[$i]}" | awk '{print $2}' || echo "-")
      
      # Get up/down state for $i
      state[$i]=$(grep -q "$i: .*,UP" <<<"${iface_input[$i]}" && echo up || echo DOWN)
      
      # Get macaddr for $i (don't show if all zeros)
      mac[$i]=$(egrep -q 'link/[[:graph:]]+ ..:..:..:..:..:..' <<<"${iface_input[$i]}" && awk '/link\/[[:graph:]]+ ..:..:..:..:..:../ {if ($2 == "00:00:00:00:00:00") print "-"; else print $2}' <<<"${iface_input[$i]}" || echo "-")
      
      # If $i has an ipv4 address, time to figure out what it is
      if grep -q "inet .* ${i%@*}\$" <<<"${iface_input[$i]}"; then
        
        # We could potentially have more than one non-alias ipaddr...
        # So we need to set up a counter and do a loop
        n=0; while read ipv4addr; do
if [[ $n -eq 0 ]]; then
echo " $i❚${slaveof[$i]}❚$ipv4addr❚${state[$i]}❚${mac[$i]}"
          else
echo " ❚ ❚$ipv4addr❚ ❚ "
          fi
n=$((n+1))
        done <<<"$(awk "/inet .* ${i%@*}\$/ {print \$2}" <<<"${iface_input[$i]}")"
      
      # Otherwise, print out all info with ipv4 addr set to "-"
      else
echo " $i❚${slaveof[$i]}❚-❚${state[$i]}❚${mac[$i]}"
        # ... And Continue on to the next interface, i.e., skip looking for aliases
        continue
fi

      # If $i had an ipv4 addr, it's ALIAS time!
      if grep -q "inet .* $i:" <<<"${iface_input[$i]}"; then
      
        # For each "alias" (additional address) found ...
        for alias in $(awk "/inet .* $i:/ {print \$NF}" <<<"${iface_input[$i]}"); do
ipv4_alias[$alias]=$(awk "/inet .* $alias\$/ {print \$2}" <<<"${iface_input[$i]}")
          
          # ... Print out a new line with its ipv4 addr
          echo " $alias❚ ❚${ipv4_alias[$alias]}❚ ❚ "
        done
fi
done
  } |
  
    # All output from above needs to be columnized
    column -ts❚ |
    
      # And then we need to do some color funness!
      # This colorizes the first 2 lines with the H2 color and the interfaces with H3
      awk -vH0="${c[0]}" -vH2="${c[H2]}" -vH3="${c[H3]}" '
{
if (NR <= 2) print H2 $0 H0
else printf gensub(/(^ [[:graph:]]+ )/, H3"\\1"H0, 1)"\n"
}'

  echo -en $XSOS_HEADING_SEPARATOR
}



ETHTOOL() {
  # Local vars:
  local changedir ethdevs i
  
  # If localhost, grab interfaces from /sys
  if [[ -z $1 ]]; then
ethdevs=$(ls /sys/class/net | egrep -v 'lo|sit0')
    # Setup local functions for ethtool & ethtool -i
    __ethtool() { ethtool $1; }
    __ethtool_i() { ethtool -i $1; }
    
  # If sosreport, determine interfaces from ethtool_<iface> files
  else
changedir=1
    pushd "$1"/sos_commands/networking &>/dev/null
    ethdevs=$(ls ethtool_[[:alpha:]]* | cut -d_ -f2)
    # Setup local functions for ethtool & ethtool -i
    __ethtool() { cat ethtool_$1; }
    __ethtool_i() { [[ -r ethtool_-i_$1 ]] && cat ethtool_-i_$1; }
  fi
  
  # If have ethdevs to work on ...
  if [[ -n $ethdevs ]]; then
echo -e "${c[H1]}ETHTOOL${c[0]}"
    for i in $ethdevs; do
echo -e " $i❚$(__ethtool $i |
awk '
/Link detected:/ { link = $3; sub(/yes/, "up", link); sub(/no/, "DOWN", link) }
/Speed:/ { spd = $2 }
/Duplex:/ { dup = tolower($2) }
/Auto-negotiation:/ { aneg = $2; sub(/on/, "Y", aneg); sub(/off/, "N", aneg) }
END {
if (link == "up" && spd != "")
linkdetails = " "spd" "dup" (autoneg="aneg")"
printf "link=%s%s❚", link, linkdetails
}
'
)$(__ethtool_i $i |
awk '
BEGIN { driver="UNKNOWN"; drv_vers=""; fw_vers="" }
/^driver:/ { if ($2 != "") driver=$2 }
/^version:/ { if ($2 != "") drv_vers=" v"$2 }
/^firmware-version:/ { if ($2 != "") fw_vers=" / fw "$2 }
END { printf "drv %s%s%s\n", driver, drv_vers, fw_vers }
'
)"
    done | column -ts❚ |
      awk -vH0="${c[0]}" -vU="${c[Up]}" -vD="${c[Down]}" '/DOWN/{print D $0 H0} /up/{print U $0 H0}'
    [[ -n $changedir ]] && popd &>/dev/null
  fi
echo -en $XSOS_HEADING_SEPARATOR
}


PROC_NET() {
  # Local vars:
  local netdev_input
  
  [[ -f $1 ]] && netdev_input=$1 || netdev_input=$1/proc/net/dev
  
  echo -e "${c[H1]}NETDEV${c[0]}"
  tail -n+3 "$netdev_input" | egrep -v 'lo:|sit0:' | sed 's,:, ,' |
    awk -vu=$(tr '[:lower:]' '[:upper:]' <<<$XSOS_NET_UNIT) '
function round(num, places) {
places = 10 ^ places
return int(num * places + .5) / places
}

{
# Set variables based on fields
Interface[$1] = $1
RxBytes[$1] = $2
RxPackets[$1] = $3
RxErrs[$1] = $4
RxDrop[$1] = $5
TxBytes[$1] = $10
TxPackets[$1] = $11
TxErrs[$1] = $12
TxDrop[$1] = $13
# Set percent variables only if gt 0
if ($4 > 0) RxErrsPercent[$1] = "(" round($4 * 100 / $3, 0) "%)"
if ($5 > 0) RxDropPercent[$1] = "(" round($5 * 100 / $3, 0) "%)"
if ($12 > 0) TxErrsPercent[$1] = "(" round($12 * 100 / $11, 0) "%)"
if ($13 > 0) TxDropPercent[$1] = "(" round($13 * 100 / $11, 0) "%)"
# Figure out what number to divide by to end up with KiB, MiB, GiB, or TiB
if (u == "K") { bytes_divisor = 1024 }
else if (u == "M") { bytes_divisor = 1024 ** 2 ; packets_divisor = 1000 ; Packets_Unit = " k" }
else if (u == "G") { bytes_divisor = 1024 ** 3 ; packets_divisor = 1000 ** 2 ; Packets_Unit = " M" }
else if (u == "T") { bytes_divisor = 1024 ** 4 ; packets_divisor = 1000 ** 2 ; Packets_Unit = " M" }
# Figure out decimal precision
if (u == "T")
# For T, round Bytes field to nearest hundredth (.nn)
Precision_Bytes = 2
else if (u == "G")
# For G, round Bytes field to nearest tenth (.n)
Precision_Bytes = 1
else
# For K/M, keep Bytes as whole numbers
Precision_Bytes = 0
# Never show decimal for Packets
Precision_Pckts = 0
# If unit is anything but bytes, perform the necessary division
if (u == "K" || u == "M" || u == "G" || u == "T") {
U = u"iB"
RxBytes[$1] /= bytes_divisor
TxBytes[$1] /= bytes_divisor
}
# If unit is MiB, GiB, or TiB, perform division on packets as well
if (u == "M" || u == "G" || u == "T") {
RxPackets[$1] /= packets_divisor
TxPackets[$1] /= packets_divisor
}
# Now that we have our numbers, time to do rounding
RxBytes[$1] = round(RxBytes[$1], Precision_Bytes)
TxBytes[$1] = round(RxBytes[$1], Precision_Bytes)
RxPackets[$1] = round(RxPackets[$1], Precision_Pckts)
TxPackets[$1] = round(TxPackets[$1], Precision_Pckts)
# If U (pretty printing unit) was never set, it should be bytes
if (U == "")
U = "B"
}
END {
print " Interface❚Rx"U"ytes❚RxPackets❚RxErrs❚RxDrop❚Tx"U"ytes❚TxPackets❚TxErrs❚TxDrop"
print " =========❚=========❚=========❚======❚======❚=========❚=========❚======❚======"
n = asorti(Interface, IF)
for (i = 1; i <= n; i++)
# printf " %s❚%.0f❚%.0f%s❚%d %s❚%d %s❚%.0f❚%.0f%s❚%d (%.0f%%)❚%d (%.0f%%)\n",
printf " %s❚%s❚%s%s❚%s %s❚%s %s❚%s❚%s%s❚%s %s❚%s %s\n",
IF[i], RxBytes[IF[i]], RxPackets[IF[i]], Packets_Unit, RxErrs[IF[i]], RxErrsPercent[IF[i]], RxDrop[IF[i]], RxDropPercent[IF[i]],
TxBytes[IF[i]], TxPackets[IF[i]], Packets_Unit, TxErrs[IF[i]], TxErrsPercent[IF[i]], TxDrop[IF[i]], TxDropPercent[IF[i]]
}
' | column -ts❚ |
      awk -vH0="${c[0]}" -vH2="${c[H2]}" -vH3="${c[H3]}" '
{
if (NR <= 2) print H2 $0 H0
else printf gensub(/(^ [[:graph:]]+ )/, H3"\\1"H0, 1)"\n"
}'

# Disabled this cuz ... well, it took up space and I had no evidence that anyone uses it
# if [[ -d $1 ]]; then
# echo -en $XSOS_HEADING_SEPARATOR
# echo -e "${c[H1]}SOCKSTAT${c[0]}"
# awk -vS=" " -vH3="${c[H3]}" -vH0="${c[0]}" '
# { printf gensub(/^(.*:)/, S H3"\\1"H0, 1)"\n" }' <"$1/proc/net/sockstat"
# fi
  echo -en $XSOS_HEADING_SEPARATOR
}


CHECK_TAINTED() {
  # Local vars:
  local sys_tainted_status tainvals taint indent t n
  
  sys_tainted_status=$(<"$1/proc/sys/kernel/tainted")
  
  if [[ $sys_tainted_status == 0 ]]; then
echo -e "0${c[0]} (kernel untainted)"
    return
else
case $2 in
      H0) indent= ;;
      H1) indent=$XSOS_INDENT_H1 ;;
      H2) indent=$XSOS_INDENT_H2 ;;
      H3) indent=$XSOS_INDENT_H3
    esac
taintvals=$(
      for taint in 536870912 268435456 4096 2048 1024 512 256 128 64 32 16 8 4 2 1; do
if [[ $sys_tainted_status -gt $taint ]]; then
printf "$taint "
          sys_tainted_status=$((tainted-taint))
        elif [[ $sys_tainted_status == $taint ]]; then
printf "$taint "
          break
fi
done
    )
  fi
  
  # See /usr/share/doc/kernel-doc*/Documentation/sysctl/kernel.txt
  # Or linux/kernel/panic.c
  t[1]="Proprietary module has been loaded"
  t[2]="Module has been forcibly loaded"
  t[4]="SMP with CPUs not designed for SMP"
  t[8]="User forced a module unload"
  t[16]="System experienced a machine check exception"
  t[32]="System has hit bad_page"
  t[64]="Userspace-defined naughtiness"
  t[128]="Kernel has oopsed before"
  t[256]="ACPI table overridden"
  t[512]="Taint on warning"
  t[1024]="Modules from drivers/staging are loaded"
  t[2048]="Working around severe firmware bug"
  t[4096]="Out-of-tree module has been loaded"
  t[268435456]="Hardware is unsupported"
  t[536870912]="Technology Preview code is loaded"
  echo -e "$taintvals${c[0]}"
  for n in $taintvals; do
echo "$indent${t[$n]}"
  done
}


SYSCTL() {
  # Local vars:
  local pgsz hpgsz
  
  # VM PageSize (don't know how to find this from a sosreport, but I doubt that will often be a problem)
  [[ $1 == / ]] && pgsz=$(($(getconf PAGESIZE)/1024)) || pgsz=4 # Saved as KiB
  
  # HugePage size
  hpgsz=$(awk '/Hugepagesize:/{print $2/1024}' <"$1/proc/meminfo") # Saved as MiB
  
  __P() {
    echo -e "$XSOS_INDENT_H2${c[H3]}${1#*.} ${c[H4]}$2${c[H3]}= $(<"$sosroot"/proc/sys/${1//.//})${c[0]}"
  }
  
  __Pa() {
    echo -e "$XSOS_INDENT_H2${c[H3]}${1#*.} ${c[H4]}$2${c[H3]}= $(awk -vH0="${c[0]}" "$3" "$4" <"$sosroot"/proc/sys/${1//.//})${c[0]}"
  }
  
  echo -e "${c[H1]}SYSCTLS${c[0]}"
  if grep -qsw rescue "$1/proc/cmdline"; then
echo -e "${c[Warn2]} WARNING: RESCUE MODE DETECTED${c[0]}"
    echo -e "${c[Warn1]} sysctls below reflect rescue env; inspect sysctl.conf manually${c[0]}"
  fi
echo -e "$XSOS_INDENT_H1${c[H2]}kernel.${c[0]}"
  __P kernel.hostname
  __P kernel.osrelease
  echo -e "$XSOS_INDENT_H2${c[H3]}tainted = $(CHECK_TAINTED "$1" H3)"
  __P kernel.random.boot_id
  __P kernel.random.entropy_avail "[bits] "
  __P kernel.hung_task_panic "[bool] "
  __Pa kernel.hung_task_timeout_secs "" '{if ($1>0) printf "%s%s (secs task must be D-state to trigger)", $1, H0; else printf "0%s (khungtaskd disabled)", H0}'
  __P kernel.msgmax "[bytes] "
  __P kernel.msgmnb "[bytes] "
  __P kernel.msgmni "[msg queues] "
  __Pa kernel.panic "[secs] " '{if ($1>0) printf "%s%s (secs til autoreboot after panic)", $1, H0; else printf "0%s (no autoreboot on panic)", H0}'
  __P kernel.panic_on_oops "[bool] "
  __P kernel.nmi_watchdog "[bool] "
  __P kernel.panic_on_io_nmi "[bool] "
  __P kernel.panic_on_unrecovered_nmi "[bool] "
  __P kernel.unknown_nmi_panic "[bool] "
  __P kernel.softlockup_panic "[bool] "
  __P kernel.softlockup_thresh "[secs] "
  __P kernel.pid_max
  __P kernel.threads-max
  __Pa kernel.sem "[array] " "-vS=$XSOS_INDENT_H3" '{printf "%s %s %s %s%s\n", $1,$2,$3,$4,H0; printf "%sSEMMSL (max semaphores per array) = %d\n%sSEMMNS (max sems system-wide) = %d\n%sSEMOPM (max ops per semop call) = %d\n%sSEMMNI (max number of sem arrays) = %d\n", S,$1, S,$2, S,$3, S,$4}'
  __Pa kernel.shmall "[$pgsz-KiB pages] " "-vPGSZ=$pgsz" '{printf "%s%s (%.1f GiB max total shared memory)", $1, H0, $1*PGSZ/1024/1024}'
  __Pa kernel.shmmax "[bytes] " '{printf "%s%s (%.2f GiB max segment size)", $1, H0, $1/1024/1024/1024}'
  __Pa kernel.shmmni "[segments] " '{printf "%s%s (max number of segs)", $1, H0}'
  __Pa kernel.sysrq "[bitmask] " '{if ($1==0) printf "0%s (disallowed)", H0; else if ($1==1) printf "1%s (all SysRqs allowed)", H0; else printf "%s%s (see proc man page)", $1, H0}'

  echo -e "$XSOS_INDENT_H1${c[H2]}fs.${c[0]}"
  __Pa fs.file-max "[fds] " '{printf "%s%s (system-wide limit on nr open file descriptors)", $1,H0}'
  #__Pa fs.nr_open "[fds] " '{printf "%s%s (upper limit for fs.file-max)", $1,H0}' # ??? FIXME: Well, that's what I thought originally, but I don't think that's it.
  __Pa fs.file-nr "[fds] " '{printf "%s %s %s%s (nr allocated fds, N/A, nr free fds)", $1,$2,$3,H0 }'
  __Pa fs.inode-nr "[inodes] " '{printf "%s %s%s (nr_inodes allocated, nr_free_inodes)", $1,$2,H0}'
  
  echo -e "$XSOS_INDENT_H1${c[H2]}net.${c[0]}"
  __Pa net.core.rmem_max "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'
  __Pa net.core.wmem_max "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'
  __Pa net.core.rmem_default "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'
  __Pa net.core.wmem_default "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'
  __P net.ipv4.icmp_echo_ignore_all "[bool] "
  __P net.ipv4.ip_forward "[bool] "
  __Pa net.ipv4.tcp_max_orphans "[sockets] " '{printf "%s%s (%d MiB @ max 64 KiB per orphan)", $1, H0, $1*64/1024}'
  __Pa net.ipv4.tcp_mem "[$pgsz-KiB pages] " "-vPGSZ=$pgsz" '{printf "%s %s %s%s (%.2f GiB, %.2f GiB, %.2f GiB)", $1, $2, $3, H0, $1*PGSZ/1024/1024, $2*PGSZ/1024/1024, $3*PGSZ/1024/1024}'
  __Pa net.ipv4.udp_mem "[$pgsz-KiB pages] " "-vPGSZ=$pgsz" '{printf "%s %s %s%s (%.2f GiB, %.2f GiB, %.2f GiB)", $1, $2, $3, H0, $1*PGSZ/1024/1024, $2*PGSZ/1024/1024, $3*PGSZ/1024/1024}'
  __P net.ipv4.tcp_window_scaling "[bool] "
  __Pa net.ipv4.tcp_rmem "[bytes] " '{printf "%s %s %s%s (%d KiB, %d KiB, %d KiB)", $1, $2, $3, H0, $1/1024, $2/1024, $3/1024}'
  __Pa net.ipv4.tcp_wmem "[bytes] " '{printf "%s %s %s%s (%d KiB, %d KiB, %d KiB)", $1, $2, $3, H0, $1/1024, $2/1024, $3/1024}'
  __Pa net.ipv4.udp_rmem_min "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'
  __Pa net.ipv4.udp_wmem_min "[bytes] " '{printf "%s%s (%d KiB)", $1, H0, $1/1024}'

  echo -e "$XSOS_INDENT_H1${c[H2]}vm.${c[0]}"
  __Pa vm.dirty_ratio "" '{if ($1>0) printf "%s%s (%% of total system memory)", $1, H0; else printf "0%s (disabled -- check dirty_bytes)", H0}'
  __Pa vm.dirty_bytes "" '{if ($1>0) printf "%s%s (%.1f MiB)", $1, H0, $1/1024/1024; else printf "0%s (disabled -- check dirty_ratio)", H0}'
  __Pa vm.dirty_background_ratio "" '{if ($1>0) printf "%s%s (%% of total system memory)", $1, H0; else printf "0%s (disabled -- check dirty_background_bytes)", H0}'
  __Pa vm.dirty_background_bytes "" '{if ($1>0) printf "%s%s (%.1f MiB)", $1, H0, $1/1024/1024; else printf "0%s (disabled -- check dirty_background_ratio)", H0}'
  __P vm.dirty_expire_centisecs
  __P vm.dirty_writeback_centisecs
  __Pa vm.nr_hugepages "[$hpgsz-MiB pages] " "-vHPGSZ=$hpgsz" '{if ($1>0) printf "%s%s (%.1f GiB total)", $1, H0, $1*HPGSZ/1024; else print $1 H0}'
  __Pa vm.overcommit_memory "[0-2] " '{if ($1==0) printf "0%s (heuristic overcommit)", H0; else if ($1==1) printf "1%s (always overcommit, never check)", H0; else if ($1==2) print "2%s (always check, never overcommit)", H0}'
  __P vm.overcommit_ratio
  __Pa vm.oom_kill_allocating_task "[bool] " '{if ($1==0) printf "0%s (scan tasklist)", H0; else printf "1%s (kill OOM-triggering task)", H0}'
  __Pa vm.panic_on_oom "[0-2] " '{if ($1==0) printf "0%s (no panic)", H0; else if ($1==1) printf "1%s (no panic if OOM-triggering task limited by mbind/cpuset)", H0; else if ($1==2) printf "2%s (always panic)", H0}'
  __P vm.swappiness "[0-100] "
  echo -en $XSOS_HEADING_SEPARATOR
}


PSCHECK() {
  # Local vars:
  local ps_input ps_header num_top_users num_comm_args num_process_lines process_line_length Dsleepers Zombies top_users top_users_header
  
  # Get input from proper place dependent on what was passed
  if [[ -z $1 ]]; then
ps_input=$(ps aux | sed '1!s/%/%%/g')
  elif [[ -f $1 ]]; then
ps_input=$(sed '1!s/%/%%/g' "$1")
  else
ps_input=$(sed '1!s/%/%%/g' "$1/ps")
  fi
  
  # Verbosity? We den need no stinkin' verbosity!
  if [[ $XSOS_PS_LEVEL == 0 ]]; then
    # V-level 0: Less than default
    num_top_users=3
    num_comm_args=0
    num_process_lines=5
    process_line_length=100
  elif [[ -z $XSOS_PS_LEVEL || $XSOS_PS_LEVEL == 1 ]]; then
    # V-level 1: Default
    num_top_users=10
    num_comm_args=2
    num_process_lines=10
    process_line_length=150
  elif [[ $XSOS_PS_LEVEL == 2 ]]; then
    # V-level 2: Verbose
    num_top_users=30
    num_comm_args=10
    num_process_lines=30
    process_line_length=512
  elif [[ $XSOS_PS_LEVEL == 3 ]]; then
    # V-level 3: MOOOAAAARR
    num_top_users=60
    num_comm_args=1023
    num_process_lines=60
    process_line_length=2047 # This is the max that `column` can handle
  elif [[ $XSOS_PS_LEVEL == 4 ]]; then
    # V-level 4: Eerrryting
    num_top_users=
    num_comm_args=1023
    num_process_lines=
    process_line_length=2047 # This is the max that `column` can handle
  fi
__conditional_head() {
  [[ -n $1 ]] &&
    echo head -n$1 ||
    echo cat
  }
  
  # First, we need to convert VSZ & RSS in the ps input to MiB or GiB (if necessary)
  # We also need to perfectly columnize the input and chop off extra command args based on above options
  ps_input=$(awk -vMAX_fields=$((num_comm_args+12)) -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
BEGIN {
# Not going to worry about down-converting to bytes or up-converting to TiB
if (u == "B") u = "K"
else if (u == "T") u = "G"
else if (u == "K" || u == "G") u = u
else u = "M"
# Figure out what number to divide by to end up with KiB or MiB or GiB
if (u == "K") divisor = 1
else if (u == "M") divisor = 1024
else if (u == "G") divisor = 1024 ** 2
# Set pretty printing unit
U = u"iB"
}
{
# Print first 4 fields
for (i=1; i<5; i++) printf $i"❚"
# Print field 5 & 6 (VSZ & RSS)
for (i=5; i<7; i++) {
if (NR == 1) printf "%s-%s❚", $i, U
else if (u == "G") printf "%.1f❚", $i/divisor
else printf "%.0f❚", $i/divisor
}
# Print fields 7-10
for (i=7; i<11; i++) printf $i"❚"
# For the last field (command) we need to chop things up
for (i=11; i<=NF && i<MAX_fields; i++) printf $i" "
printf "\n"
}' <<<"$ps_input" | cut -c-$process_line_length | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,")
    
  # Deal with header
  ps_header=$(head -n1 <<<"$ps_input")
  ps_input=$(tail -n+2 <<<"$ps_input")
  
  # Format and prepare sleeping/zombie processes
  Dsleepers=$(awk -vcolor_warn="${c[Warn1]}" -vc_0="${c[0]}" '$8~/D/ {print color_warn $0 c_0}' <<<"$ps_input")
  Zombies=$(awk -vc_grey="${c[DGREY]}" -vc_0="${c[0]}" '$8~/Z/ {print c_grey $0 c_0}' <<<"$ps_input")
  [[ -n $Dsleepers ]] && Dsleepers="\n$Dsleepers"
  [[ -n $Zombies ]] && Zombies="\n$Zombies"
  [[ -z $Dsleepers && -z $Zombies ]] && Dsleepers="\n$XSOS_INDENT_H2${c[dgrey]}(None)${c[0]}"
  
  # Calculte top cpu-using & mem-using users
  if [[ $XSOS_PS_LEVEL < 3 ]]; then # If verbosity level 0-2, restrict number of users shown
    # Process ps input to generate summary user-list of top-users
    top_users=$(
      awk -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
BEGIN { print "USER❚%CPU❚%MEM❚RSS" }
{ pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6 }
END {
# Figure out what number to divide by to end up with GiB
if (u == "K") divisor = 1024 ** 2
else if (u == "M") divisor = 1024
else if (u == "G") divisor = 1
for (user in pCPU)
# Only show if greater than 0% CPU and 0.1% MEM
if (pCPU[user]>0 || pMEM[user]>0.1)
printf "%s❚%.1f%%❚%.1f%%❚%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/divisor
}
' <<<"$ps_input" | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,")
    # Grab header from the top
    top_users_header=$(head -n1 <<<"$top_users")
  
  else # If verbosity level 3-4, show all users
    # Process ps input to generate summary user-list of top-users
    top_users=$(
      awk -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
BEGIN { print "USER❚%CPU❚%MEM❚RSS" }
{ pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6 }
END {
# Figure out what number to divide by to end up with GiB
if (u == "K") divisor = 1024 ** 2
else if (u == "M") divisor = 1024
else if (u == "G") divisor = 1
for (user in pCPU)
printf "%s❚%.1f%%❚%.1f%%❚%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/divisor
}
' <<<"$ps_input" | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,")
    # Grab header from the top
    top_users_header=$(head -n1 <<<"$top_users")
  fi
  
  # Remove header from the top and sort everything else by %CPU, potentially trimming down list
  top_users=$(tail -n+2 <<<"$top_users" | sort -rnk2 | $(__conditional_head $num_top_users))
  
  # Print!
  echo -e "${c[H1]}PS CHECK${c[0]}
$XSOS_INDENT_H1${c[H2]}Total number of processes:${c[0]} \n$XSOS_INDENT_H2${c[Imp]}$(wc -l <<<"$ps_input")${c[0]}
$XSOS_INDENT_H1${c[H2]}Top users of CPU & MEM:${c[0]} \n${c[H3]}$top_users_header${c[0]} \n$top_users
$XSOS_INDENT_H1${c[H2]}Uninteruptible sleep & Defunct processes:${c[0]} \n${c[H3]}$ps_header${c[0]} $Dsleepers $Zombies
$XSOS_INDENT_H1${c[H2]}Top CPU-using processes:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk3 <<<"$ps_input" | $(__conditional_head $num_process_lines))
$XSOS_INDENT_H1${c[H2]}Top MEM-using processes:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk6 <<<"$ps_input" | $(__conditional_head $num_process_lines))"
  echo -en $XSOS_HEADING_SEPARATOR
}


#-------------------------------------------------------------------------------
# BLEH
# Eventually I'll probably replace all of this with a python loader.
# Python's argparse is so much better than dealing with all this crap.

# Used to check for existence of files on a sosreport and print errors to stderr
SOS_CHECKFILE() {
  local module firstfile
  # $1: module name, e.g. bios, os, cpu, mem
  # $2+: file names, i.e. potential files to be found in sosreport root
  module=$1; shift; firstfile=$1
  # If module needs to be called, check for files
  if [[ $(eval echo \$$module) == y ]]; then
while [[ $# -gt 0 ]]; do
      # If ethtool module being called, do something specific
      if [[ $module == ethtool ]] && ls "$sosroot"/$1 &>/dev/null; then
return # Return successfully if ethtool files found
      # If file ends in slash, look for dir
      elif [[ $1 =~ /$ ]]; then
        [[ -d $sosroot/$1 ]] && return # Return successfully if dir found
      else
        [[ -r $sosroot/$1 ]] && return # Return successfully if file readable
      fi
shift
done
else
return # If module doesn't need to be called, return success
  fi
  # If we're still here, a module for which we don't have files was requested -- warn
  echo -e "${c[Warn2]}Warning:${c[Warn1]} '$sosroot/$firstfile' file unreadable; skipping $module check${c[0]}" >&2
  echo -en $XSOS_HEADING_SEPARATOR >&2
  return 1
}

# Used to conditionally run certain functions when running on localhost
COND_RUN() {
  if [[ $2 == --require_root && $UID != 0 ]]; then
echo -e "${c[Warn2]}Warning:${c[Warn1]} Need root access to run $1 command on localhost${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  elif command -v $1 &>/dev/null; then
    # The following tr command translates $1 to the uppercase function name, e.g. lspci --> LSPCI
    # In a BASHv4-only world, this could be done with simply: ${1^^}
    $(tr '[:lower:]' '[:upper:]' <<<"$1")
  else
echo -e "${c[Warn2]}Warning:${c[Warn1]} $1 command not present in PATH${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  fi
}


{
# If special options and files were provided ....
if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
  [[ -r ${sfile[B]} ]] && DMIDECODE "${sfile[B]}"
  [[ -r ${sfile[C]} ]] && CPUINFO "${sfile[C]}"
  [[ -r ${sfile[M]} ]] && MEMINFO "${sfile[M]}"
  [[ -r ${sfile[D]} ]] && STORAGE "${sfile[D]}"
  [[ -r ${sfile[L]} ]] && LSPCI "${sfile[L]}"
  [[ -r ${sfile[I]} ]] && IPADDR "${sfile[I]}"
  [[ -r ${sfile[N]} ]] && PROC_NET "${sfile[N]}"
  [[ -r ${sfile[P]} ]] && PSCHECK "${sfile[P]}"

# If SOSREPORT-ROOT provided, use that
elif [[ -n $sosroot ]]; then
SOS_CHECKFILE bios {,sos_commands/kernel.}dmidecode && DMIDECODE "$sosroot"
  SOS_CHECKFILE os "proc/" && OSINFO "$sosroot"
  SOS_CHECKFILE cpu "proc/cpuinfo" && CPUINFO "$sosroot"
  SOS_CHECKFILE mem "proc/meminfo" && MEMINFO "$sosroot"
  SOS_CHECKFILE disks "proc/partitions" && STORAGE "$sosroot" --mpath
  SOS_CHECKFILE lspci "lspci" && LSPCI "$sosroot"
  SOS_CHECKFILE ethtool "sos_commands/networking/ethtool*" && ETHTOOL "$sosroot"
  SOS_CHECKFILE ip "sos_commands/networking/ip_address" && IPADDR "$sosroot"
  SOS_CHECKFILE net "proc/net/" && PROC_NET "$sosroot"
  SOS_CHECKFILE sysctl "proc/sys/" && SYSCTL "$sosroot" 2>/dev/null
  SOS_CHECKFILE ps "ps" && PSCHECK "$sosroot"
  
# If no SOSREPORT-ROOT provided, run checks against local system
else
  [[ -n $bios ]] && COND_RUN dmidecode --require_root
  [[ -n $os ]] && OSINFO /
  [[ -n $cpu ]] && CPUINFO /
  [[ -n $mem ]] && MEMINFO /
  [[ -n $disks ]] && STORAGE / --mpath
  [[ -n $lspci ]] && COND_RUN lspci
  [[ -n $ethtool ]] && COND_RUN ethtool --require_root
  [[ -n $ip ]] && IPADDR
  [[ -n $net ]] && PROC_NET /
  [[ -n $sysctl ]] && SYSCTL / 2>/dev/null
  [[ -n $ps ]] && PSCHECK

fi
} | $XSOS_OUTPUT_HANDLER
